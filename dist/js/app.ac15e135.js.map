{"version":3,"file":"js/app.ac15e135.js","mappings":"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","sources":["webpack://ezloading/./src/App.vue","webpack://ezloading/./src/components/EzLoading.vue","webpack://ezloading/./src/components/AddDialog.vue","webpack://ezloading/./src/components/AddDialog.vue?390e","webpack://ezloading/./src/components/TruckDialog.vue","webpack://ezloading/./src/components/TruckDialog.vue?aef7","webpack://ezloading/./src/components/PalletKonvaGroup.vue","webpack://ezloading/./src/components/PalletKonvaGroup.vue?a53d","webpack://ezloading/./src/assets/collision.js","webpack://ezloading/./src/components/EzLoading.vue?4ec4","webpack://ezloading/./src/App.vue?7ccd","webpack://ezloading/./src/main.js","webpack://ezloading/webpack/bootstrap","webpack://ezloading/webpack/runtime/chunk loaded","webpack://ezloading/webpack/runtime/compat get default export","webpack://ezloading/webpack/runtime/define property getters","webpack://ezloading/webpack/runtime/global","webpack://ezloading/webpack/runtime/hasOwnProperty shorthand","webpack://ezloading/webpack/runtime/make namespace object","webpack://ezloading/webpack/runtime/node module decorator","webpack://ezloading/webpack/runtime/jsonp chunk loading","webpack://ezloading/webpack/startup"],"sourcesContent":["<template>\r\n  <EzLoading/>\r\n</template>\r\n\r\n<script>\r\nimport EzLoading from './components/EzLoading.vue'\r\n\r\nexport default {\r\n  name: 'App',\r\n  components: {\r\n    EzLoading\r\n  },\r\n}\r\n</script>\r\n\r\n<style>\r\n#app {\r\n  font-family: Avenir, Helvetica, Arial, sans-serif;\r\n  -webkit-font-smoothing: antialiased;\r\n  -moz-osx-font-smoothing: grayscale;\r\n  text-align: center;\r\n  color: #2c3e50;\r\n  margin-top: 30px;\r\n}\r\n\r\n\r\n</style>\r\n","<template>\n    <v-layout>\n        <v-app-bar color=\"primary\">\n\n\n            <v-app-bar-nav-icon @click.stop=\"drawer = !drawer\"></v-app-bar-nav-icon>\n\n\n            <div class=\"d-flex\">\n                <truck-dialog customClasses=\"ma-2 px-4\" variantStyle=\"outlined\" customColor=\"white\"\n                    :mobileOrDesktop=\"this.displayWidth\" :customStyle=\"{ backgroundColor: 'green' }\"\n                    @load-space-set=\"loadSpaceSet\" />\n\n                <add-dialog customClasses=\"ma-2 px-4\" variantStyle=\"outlined\" customColor=\"white\"\n                    :mobileOrDesktop=\"this.displayWidth\" :customStyle=\"{ backgroundColor: 'green' }\"\n                    @cargo-added=\"addCargo\" />\n\n                <!-- This menu is for debugging delete it -->\n                <!-- <v-menu>\n                    <template v-slot:activator=\"{ props }\">\n                        <v-btn class=\"ma-2 px-4\" :style=\"{ backgroundColor: 'green' }\" color=\"white\" v-bind=\"props\">\n                            DEBUG MENU\n                        </v-btn>\n                    </template>\n                    <v-list>\n                        <v-list-item :key=\"1\" :value=\"0\" @click=\"processImpactStart\">\n                            <v-list-item-title>processImpactStart</v-list-item-title>\n                        </v-list-item>\n                        <v-list-item :key=\"1\" :value=\"0\" @click=\"TESTING_ForceHighlight\">\n                            <v-list-item-title>TESTING_ForceHighlight</v-list-item-title>\n                        </v-list-item>\n                        <v-list-item :key=\"2\" :value=\"1\" @click=\"TESTING_findOverlaps\">\n                            <v-list-item-title>TESTING_findOverlaps</v-list-item-title>\n                        </v-list-item>\n                        <v-list-item :key=\"3\" :value=\"0\" @click=\"TESTING_PrintCargo\">\n                            <v-list-item-title>TESTING_PrintCargo</v-list-item-title>\n                        </v-list-item>\n                        <v-list-item :key=\"5\" :value=\"1\" @click=\"TESTING_dedupeStackedCargo_dummy\">\n                            <v-list-item-title>TESTING_dedupeStackedCargo_dummy</v-list-item-title>\n                        </v-list-item>\n                        <v-list-item :key=\"6\" :value=\"1\" @click=\"TESTING_pixelPush_dummy\">\n                            <v-list-item-title>TESTING_pixelPush_dummy</v-list-item-title>\n                        </v-list-item>\n\n                    </v-list>\n                </v-menu>\n\n\n                <v-btn v-if=\"this.displayWidth === 'desktop'\" :style=\"{ backgroundColor: 'green' }\" class=\"ma-2 px-4\"\n                    color=\"white\" @click=\"TESTING_Setup1()\"> TESTING_Setup1() </v-btn>\n\n                <v-btn v-if=\"this.displayWidth === 'desktop'\" :style=\"{ backgroundColor: 'green' }\" class=\"ma-2 px-4\"\n                    color=\"white\" @click=\"TESTING_Setup2()\"> TESTING_Setup2() </v-btn>\n\n                <v-btn v-if=\"this.displayWidth === 'desktop'\" :style=\"{ backgroundColor: 'green' }\" class=\"ma-2 px-4\"\n                    color=\"white\" @click=\"TESTING_guideWalls()\"> TESTINGGUIDEWALLS </v-btn> -->\n            </div>\n\n            <v-app-bar-title>Ez-Loading</v-app-bar-title>\n\n\n        </v-app-bar>\n\n\n        <v-navigation-drawer v-model=\"drawer\" location=\"left\" temporary>\n            <div class=\"d-flex flex-column\">\n                <v-sheet class=\"ma-2\">\n                    <truck-dialog :blockStyle=\"true\" mobileOrDesktop=\"desktop\" @load-space-set=\"loadSpaceSet\" />\n                </v-sheet>\n                <v-sheet class=\"ma-2\">\n                    <add-dialog :blockStyle=\"true\" mobileOrDesktop=\"desktop\" @cargo-added=\"addCargo\" />\n                </v-sheet>\n                <v-container class=\"ma-2\" v-for=\"item in this.generateNavDrawerList\" :key=\"item.title\">\n                    <v-row>\n                        <v-col cols=\"2\" align-self=\"center\" class=\"ma-0 pa-0\" :style=\"{ userSelect: 'none' }\">\n                            <v-btn variant=\"tonal\" density=\"compact\" icon=\"mdi-trash-can-outline\" color=\"primary\"\n                                @click=\"deleteCargoCategory(item)\" @tap=\"deleteCargoCategory(item)\"></v-btn>\n                        </v-col>\n                        <v-col cols=\"5\" align-self=\"center\" class=\"ma-0 pa-0\" :style=\"{ userSelect: 'none' }\">\n                            {{ item.title }}\n                        </v-col>\n                        <v-col cols=\"2\" align-self=\"center\" class=\"ma-0 pa-0\" :style=\"{ userSelect: 'none' }\">\n                            <v-btn variant=\"tonal\" density=\"compact\" icon=\"mdi-minus\" color=\"primary\"\n                                @click=\"deleteCargoCategoryItem(item)\" @tap=\"deleteCargoCategoryItem(item)\"></v-btn>\n                        </v-col>\n                        <v-col cols=\"1\" align-self=\"center\" class=\"ma-0 pa-0\" :style=\"{ userSelect: 'none' }\">\n                            {{ item.value.length }}\n                        </v-col>\n                        <v-col cols=\"2\" align-self=\"center\" class=\"ma-0 pa-0\" :style=\"{ userSelect: 'none' }\">\n                            <v-btn variant=\"tonal\" density=\"compact\" icon=\"mdi-plus\" color=\"primary\"\n                                @click=\"addCargo(item['value'][0]['units'], item['value'][0]['dimx'], item['value'][0]['dimy'])\"\n                                @tap=\"addCargo(item['value'][0]['units'], item['value'][0]['dimx'], item['value'][0]['dimy'])\"></v-btn>\n                        </v-col>\n                    </v-row>\n                </v-container>\n            </div>\n        </v-navigation-drawer>\n\n        <v-main id=\"container\" class=\"d-flex align-center justify-center\">\n\n        </v-main>\n\n    </v-layout>\n\n    <v-stage ref=\"stage\" :config=\"stageConfig\">\n        <!-- <v-layer :config=\"{draggable: true}\"\n        @mousemove=\"handleMouseMove\" @pointerdown=\"handlePointerDown\" @dragstart=\"handleDragStart\"\n        @dragmove='handleDragMove' @dragend='handleDragEnd' ref=\"layer\"> -->\n        <v-layer \n        @mousemove=\"handleMouseMove\" @pointerdown=\"handlePointerDown\" @dragstart=\"handleDragStart\"\n        @dragmove='handleDragMove' @dragend='handleDragEnd' ref=\"layer\">\n        <!-- backing rectangle -->\n        <!-- <v-rect :config=\"backingRectConfig\"/> -->\n\n        <!-- truck left wall -->\n        <v-rect truckId='leftWall' :config=\"{\n            id: 'truckWall',\n            x: this.truck.originx,\n            y: this.truck.originy,\n            width: 10,\n            height: this.truck.units === 'Imperial' ? this.truck.dimy * this.scaleFactor : this.truck.dimy * 0.3937 * this.scaleFactor,\n            fill: 'black',\n        }\" />\n        <!-- truck back wall -->\n        <v-rect truckId='backWall' :config=\"{\n            id: 'truckWall',\n            x: this.truck.originx + 10,\n            y: this.truck.originy,\n            width: this.truck.units === 'Imperial' ? this.truck.dimx * this.scaleFactor : this.truck.dimx * 0.3937 * this.scaleFactor,\n            height: 10,\n            fill: 'black',\n        }\" />\n        <!-- truck right wall -->\n        <v-rect truckId='rightWall' :config=\"{\n            id: 'truckWall',\n            x: this.truck.units === 'Imperial' ? this.truck.originx + this.truck.dimx * this.scaleFactor + 10 : this.truck.originx + this.truck.dimx * 0.3937 * this.scaleFactor + 10,\n            y: this.truck.originy,\n            width: 10,\n            height: this.truck.units === 'Imperial' ? this.truck.dimy * this.scaleFactor : this.truck.dimy * 0.3937 * this.scaleFactor,\n            fill: 'black',\n        }\" />\n\n        <template v-for=\"(item, index) in cargo\" :key=\"item.id\">\n        <!-- everything in the group is  offset by a 10x10 pixel square in the v-group, -->\n        <!-- :cargoId accessible from layer children el: el.attrs.cargoId  -->\n        <pallet-konva-group :truck=\"this.truck\" :item=\"item\" :index=\"index\" :scaleFactor=\"this.scaleFactor\"\n        :lowestYBound=\"this.lowestYBound()\" @delete-cargo=\"deleteCargo(item, index)\"\n        @rotate-cargo=\"rotateCargo(item, index)\" />\n        </template>\n        </v-layer>\n        <!-- <v-layer ref=\"buttonlayer\">\n        \n            <v-group ref=\"buttonGroup\">\n\n                <v-label @click=\"TESTING_BUTTON1\" :config=\"{\n                    x: 30,\n                    y: 30,\n                    opacity: 0.75\n                }\">\n                <v-tag :config=\"{ fill: 'lightgrey' }\" />\n                <v-text :config=\"{\n                    text: 'zoom in',\n                    fontFamily: 'Calibri',\n                    fontSize: 18,\n                    padding: 5,\n                    fill: 'black'\n                }\" />\n                </v-label>\n\n                <v-label @click=\"TESTING_BUTTON2\" :config=\"{\n                    x: 30,\n                    y: 60,\n                    opacity: 0.75\n                }\">\n                <v-tag :config=\"{ fill: 'lightgrey' }\" />\n                <v-text :config=\"{\n                    text: 'zoom out',\n                    fontFamily: 'Calibri',\n                    fontSize: 18,\n                    padding: 5,\n                    fill: 'black'\n                }\" />\n                </v-label>\n\n                <v-label @click=\"TESTING_BUTTON3\" :config=\"{\n                    x: 30,\n                    y: 90,\n                    opacity: 0.75\n                }\">\n                <v-tag :config=\"{\n                    fill: 'lightgrey'\n                }\" />\n                <v-text :config=\"{\n                    text: 'reset',\n                    fontFamily: 'Calibri',\n                    fontSize: 18,\n                    padding: 5,\n                    fill: 'black'\n                }\" />\n                </v-label>\n\n\n                </v-group>\n\n                </v-layer> -->\n\n        </v-stage>\n</template>\n\n\n\n<script>\n//import Konva from \"konva\";\nimport { computed } from 'vue'\nimport { useDisplay } from 'vuetify'\nimport { groupBy, orderBy, uniqueId } from 'lodash'\n\nimport AddDialog from './AddDialog.vue'\nimport TruckDialog from './TruckDialog.vue'\nimport PalletKonvaGroup from './PalletKonvaGroup.vue'\n\nimport * as collision from '../assets/collision.js'\n\nconst width = window.innerWidth;\nconst height = window.innerHeight;\n\n\nexport default {\n    name: 'EzLoading',\n    components: {\n        AddDialog, TruckDialog, PalletKonvaGroup\n    },\n    \n    mounted() {\n        //If you set style from css id=#container, then only parent of actual inner container is stylized\n        this.$refs.stage.getStage().container().style.backgroundColor='#f0f0f0';\n        this.$refs.stage.getStage().container().style.border='2px solid black';\n        window.addEventListener(\"resize\", this.resizeStage);\n        this.resizeStage();\n        this.truck.originx = this.truckLocationX();\n    },\n    unmounted() {\n        window.removeEventListener(\"resize\", this.resizeStage);\n    },\n    setup() {\n        const { name } = useDisplay()\n        \n        const displayWidth = computed(() => {\n            // console.log(name.value);\n            // name is reactive and\n            // must use .value\n            switch (name.value) {\n            case 'xs':\n            case 'sm': return \"mobile\"\n            case 'md': \n            case 'lg': \n            case 'xl': \n            case 'xxl': return \"desktop\"\n            default: return \"desktop\"\n            }\n        })\n        \n        return { displayWidth }\n        \n    },\n    \n    \n    data() {\n        return {\n            drawer: false,\n            group: null,\n            saveStartDragCoords: {x: 0, y: 0},\n            dialog: false,\n            scaleFactor: 2,\n            stageConfig: {\n                // draggable: true,\n                container: 'container',\n                width: width,\n                height: height,\n                scaleX: 1,\n                scaleY: 1,                \n            },\n            backingRectConfig: {\n                id: 'truckFloor',\n                width: width,\n                height: height,\n                // for debugging purposes, delete fill to make it transparent:\n                fill: '#ffffcc',\n            },\n            truck: {units: \"Imperial\", originx: 679, originy: 10, dimx: 102, dimy: 576 },\n            cargo: [],\n            // cargo: [{id: uniqueId(\"cargo-\"), units: \"Imperial\", dimx: 20, dimy: 40},\n            //         {id: uniqueId(\"cargo-\"), units: \"Imperial\", dimx: 10, dimy: 30},\n            //         {id: uniqueId(\"cargo-\"), units: \"Imperial\", dimx: 50, dimy: 40},\n            //         {id: uniqueId(\"cargo-\"), units: \"Imperial\", dimx: 10, dimy: 20},\n            //         {id: uniqueId(\"cargo-\"), units: \"Imperial\", dimx: 5, dimy: 11}],\n            closeIcon: null,\n            rotateIcon: null,\n            \n        };\n    },\n    methods: {\n        prObj(obj) {return JSON.stringify(obj, undefined, 2)},\n        // ---------------------------------------------------------------------------------------------------\n        // start tdd -----------------------------------------------------------------------------------------\n        /* eslint-disable */ \n        prt(variableName, debugVar) {\n            console.log(variableName + \":\");\n            debugVar === undefined ? console.log(`${variableName} is undefined`) : console.log(debugVar);\n        },\n        TESTING_BUTTON1() {\n            console.log(\"button1 clicked\");\n            this.scaleFactor = this.scaleFactor * 1.1;\n            var layerChildren = this.$refs.layer.getNode().getLayer().children;\n\n            // var wallsArray = layerChildren.filter(x=>x.id()==='truckWall');\n            // var cargoGroupArray = layerChildren.filter(x => (x.id() === 'cargoGroup'))\n            // cargoGroupArray.forEach(function(cargo){\n            //     cargo.x(cargo.x()*1.1)\n            //     cargo.y(cargo.y()*1.1)\n            // })\n\n            \n        },\n        TESTING_BUTTON2() {\n            console.log(\"button2 clicked\");\n            this.scaleFactor = this.scaleFactor / 1.1\n        },\n        TESTING_BUTTON3() {\n            console.log(\"button3 clicked\");\n            this.scaleFactor = 2\n        },\n        TESTING_findOverlaps() {\n            var layerChildren = this.$refs.layer.getNode().getLayer().children;\n            var target = layerChildren.find(x=>x.attrs.cargoId === 'cargo-1');\n            collision.findOverlaps(target, target.x(), target.y(), layerChildren);\n        },\n        TESTING_dedupeStackedCargo_dummy(){\n            // testing: TESTING_dedupeStackedCargo ----------------------------------------------------------\n            var layerChildren = this.$refs.layer.getNode().getLayer().children;\n            var target = layerChildren.find(x => x.attrs.cargoId === 'cargo-1');\n\n            collision.dedupeStackedCargo(target, layerChildren);\n        },\n        TESTING_pixelPush_dummy() {\n            var layerChildren = this.$refs.layer.getNode().getLayer().children;\n            var target = layerChildren.find(x => x.attrs.cargoId === 'cargo-1');\n\n            collision.pixelPush(target, layerChildren, this.saveStartDragCoords);\n        },\n        TESTING_Setup1() {\n            console.log(\"TESTING_Setup1() called\");\n            //add cargo1 and set position\n            this.addCargo('Imperial', \"48.00\", \"40.00\"); //overlap cases\n            this.addCargo('Imperial', \"48.00\", \"40.00\");\n        },\n        TESTING_Setup2() {\n            var layerChildren = this.$refs.layer.getNode().getLayer().children;\n            var cargoGroupArray = layerChildren.filter(el => (el.id() === 'cargoGroup'))\n            var testCargo1 = cargoGroupArray[0]\n            var testCargo1Rect = testCargo1.findOne('Rect').getClientRect();\n            var testCargo2 = cargoGroupArray[1]\n            var testCargo2Rect = testCargo2.findOne('Rect').getClientRect();\n\n            //testing pixelpushing\n            //leftwall->[2][1][3]\n            // testCargo1.x(750);\n            // testCargo1.y(270);\n            // testCargo1.moveToTop();\n            // testCargo2.x(693);\n            // testCargo2.y(250);\n            // testCargo3.x(805);\n            // testCargo3.y(250);\n\n            //topwall->[2][1][3]\n            var testCargo1Coordinates = \"[280, 170]\"\n            testCargo1.x(280);\n            testCargo1.y(130);\n            testCargo2.x(430);\n            testCargo2.y(170);\n        },\n        TESTING_PrintCargo() {\n            console.table(this.cargo);\n        },\n        TESTING_ForceHighlight() {\n            var layerChildren = this.$refs.layer.getNode().getLayer().children;\n            var target = layerChildren.find(x => x.attrs.cargoId === 'cargo-1');\n\n            var topBorder = target.findOne(x=>x.id() === 'topBorder');\n            var bottomBorder = target.findOne(x => x.id() === 'bottomBorder');\n            var rightBorder = target.findOne(x => x.id() === 'rightBorder');\n            var leftBorder = target.findOne(x => x.id() === 'leftBorder');\n            topBorder.stroke('red');\n            topBorder.shadowEnabled(false);\n            bottomBorder.stroke('red');\n            bottomBorder.shadowEnabled(false);\n            rightBorder.stroke('red');\n            rightBorder.shadowEnabled(false);\n            leftBorder.stroke('red');\n            leftBorder.shadowEnabled(false);\n        },\n        // targetXPos and targetYPos are used to evaluate collision with prospective new coordinates for cargo being bumped\n        // otherwise cargo will only process wall collision if the old stale coordinates of target are intersecting a wall\n        processImpactStart() {\n            //processImpactStart(event) { //@dragend event\n            console.log(\"processImpactStart called\");\n            var layerChildren = this.$refs.layer.getNode().getLayer().children;\n            //grabbing the first cargoGroup object from layer children does not work because order changes when z-index changes\n            //therefore fetch and compare with the first element in this.cargo local data\n            var testCargo1 = layerChildren.find(el=>(el.attrs.cargoId === this.cargo[0].id))\n            //var testCargo1 = event.target //@dragend event\n            var testCargoRect1 = testCargo1.findOne('Rect').getClientRect();\n            \n            var unresolvedArray = layerChildren.filter(el=> (!(el.attrs.cargoId === testCargo1.attrs.cargoId) &&\n                                                             !(el.id() === 'truckWall') && !(el.id() === 'truckFloor')))\n            // add x/y coordinates and wallstatus for unresolvedArray for blowback lazy new position processing\n            unresolvedArray = unresolvedArray.map(x=>[x, x.x(), x.y(), 'isNotWall'])\n            \n            var resolvedArray = collision.processImpact(testCargo1, testCargo1.x(), testCargo1.y(), 'isNotWall', unresolvedArray, \"\", layerChildren);\n            \n            console.log(\"final resolvedArray from processImpactStart()\");\n            console.table(resolvedArray.map(x=>[x[0].attrs.cargoId, x[1], x[2],x[3]]));\n            resolvedArray.forEach( function(kgroup) {\n                var collidedItem = kgroup[0];\n                collidedItem.x(kgroup[1]);\n                collidedItem.y(kgroup[2]);\n            })\n            \n        },\n        handleDragStart(event) {\n            this.saveStartDragCoords.x = event.target.x()\n            this.saveStartDragCoords.y = event.target.y()\n            //console.log(`dragstart event: event.target.findOne('Rect').getClientRect() ${JSON.stringify(event.target.findOne('Rect').getClientRect(), undefined, 2)}`); //tmpdbg\n            // {\n            //     \"x\": 40,\n            //     \"y\": 40,\n            //     \"width\": 100,\n            //     \"height\": 80\n            // }\n            //console.log(`this.saveStartDragCoords.x ${this.saveStartDragCoords.x} this.saveStartDragCoords.y ${this.saveStartDragCoords.y}`); //tmpdbg\n            // this.saveStartDragCoords.x 40 this.saveStartDragCoords.y 40\n        },\n        handleMouseMove() {\n            var layerChildren = this.$refs.layer.getNode().getLayer().children;\n            this.cargo.forEach(function(cargoItem){\n                // for each cargo item update it's x and  y values\n                var cargoKObj = layerChildren.find(x=>(x.attrs.cargoId === cargoItem.id))\n                cargoItem.x = cargoKObj.x();\n                cargoItem.y = cargoKObj.y();\n            })\n        },\n        // used for border highlighting in handleDragMove(event) {...}\n        isCargoOutside(layerChildren, target, collidedCargoArray) {\n            //var layerChildren = this.$refs.layer.getNode().getLayer().children;\n            //var target = layerChildren.find(x => x.attrs.cargoId === 'cargo-1');\n            // collidedCargo is [Group, {intersectionResult: true, transform: {}}]\n            var collidedCargo = collidedCargoArray[0];\n            var collidedCargoRect = collidedCargo.findOne('Rect').getClientRect();\n\n            var leftWall = layerChildren.find(el=>(el.attrs.truckId === 'leftWall'))\n            var backWall = layerChildren.find(el=>(el.attrs.truckId === 'backWall'))\n            var rightWall = layerChildren.find(el=>(el.attrs.truckId === 'rightWall'))\n\n            if (collidedCargo.x() + collidedCargoRect.width - 1 < leftWall.x() ||\n                rightWall.x() + rightWall.width() < collidedCargo.x() ||\n                collidedCargo.y() + collidedCargoRect.height < backWall.y()) {\n                //console.log(\"cargo is outside\");   \n                return true;    \n            } else {\n                //console.log(\"cargo is inside\");\n                return false;    \n            }\n        },\n        guideLinesoldversion(target, layerChildren) {\n            // TODO: 0. destroy all guidelines from layer\n            var targetRect = target.findOne('Rect').getClientRect();\n            var targetFirstXPos = target.absolutePosition().x;\n            var targetThirdXPos = target.absolutePosition().x + targetRect.width;\n\n            var targetFirstYPos = target.absolutePosition().y;\n            var targetThirdYPos = target.absolutePosition().y + targetRect.height;\n\n            var cargoGroupArray = layerChildren.filter(x => (x.id() === 'cargoGroup' && !(x.attrs.cargoId === target.attrs.cargoId)))\n\n            var stage = this.$refs.stage.getStage()\n            var layer = this.$refs.layer.getNode().getLayer();\n\n            function drawGuide(orientation, anchorCoordinate) {\n                if (orientation == 'vertical') {\n                    var line = new Konva.Line({\n                        points: [anchorCoordinate, -6000, anchorCoordinate, 6000],\n                        stroke: 'rgb(0, 161, 255)',\n                        strokeWidth: 1,\n                        id: orientation + anchorCoordinate,\n                        name: 'guid-line',\n                        dash: [4, 6],\n                    });\n                    // if a line with the same orientation+anchorCoordinate id does not already exist then add it\n                    if(!layer.children.find(x=> (x.name() === 'guid-line' && x.id() === orientation+anchorCoordinate))){\n                        layer.add(line);\n                    }\n                } else { // orientation == 'horizontal'\n                    var line = new Konva.Line({\n                        points: [-6000, anchorCoordinate, 6000, anchorCoordinate],\n                        stroke: 'rgb(0, 161, 255)',\n                        strokeWidth: 1,\n                        id: orientation + anchorCoordinate,\n                        name: 'guid-line',\n                        dash: [4, 6],\n                    });\n                    // if a line with the same orientation+anchorCoordinate id does not already exist then add it\n                    if(!layer.children.find(x=> (x.name() === 'guid-line' && x.id() === orientation+anchorCoordinate))){\n                        layer.add(line);\n                    }\n\n                }\n            }\n            function generateGuidelineObject(kObj) {\n                var kObjRect = kObj.findOne('Rect').getClientRect()\n                var leftGuide = { \n                    startInterval: (kObj.absolutePosition().x - 5), \n                    endInterval: (kObj.absolutePosition().x + 5), \n                    anchor: kObj.absolutePosition().x - 1};\n                var rightGuide = {\n                    startInterval: (kObj.absolutePosition().x + kObjRect.width - 5),\n                    endInterval: (kObj.absolutePosition().x + kObjRect.width + 5),\n                    anchor: kObj.absolutePosition().x + kObjRect.width };\n                var aboveGuide = {\n                    startInterval: (kObj.absolutePosition().y - 5),\n                    endInterval: (kObj.absolutePosition().y + 5),\n                    anchor: kObj.absolutePosition().y - 1};\n                var belowGuide = {\n                    startInterval: (kObj.absolutePosition().y + kObjRect.height - 5),\n                    endInterval: (kObj.absolutePosition().y + kObjRect.height + 5),\n                    anchor: kObj.absolutePosition().y + kObjRect.height};\n\n                return { cargoId: kObj.attrs.cargoId, leftGuide: leftGuide, rightGuide: rightGuide, aboveGuide: aboveGuide, belowGuide: belowGuide };\n            }\n            var guideLinesArray = cargoGroupArray.map(x => generateGuidelineObject(x))\n            guideLinesArray.forEach(function (g) {\n                // LEFTGUIDE:\n                // snap to guideline gutter, and draw the guideline   \n                // target leftmost x point (should be 1 pixel more for right guide)\n                // OR target rightmost x point (should be 1 pixel less for left guide)\n                // else delete all guidelines\n                var isFirstXPosInGutter = (g.leftGuide.startInterval < targetFirstXPos && targetFirstXPos < g.leftGuide.endInterval)\n                var isThirdXPosInGutter = (g.leftGuide.startInterval < targetThirdXPos && targetThirdXPos < g.leftGuide.endInterval)\n                if (isFirstXPosInGutter || isThirdXPosInGutter) {\n                    // geometrically the two conditions must be exclusively (XOR) true    \n                    switch (true) {\n                        case isFirstXPosInGutter:\n                            // caution: if you use targetFirstXYPos instead target.absolutePosition() the target will no longer be clamped to the vertical guide\n                            target.absolutePosition({ x: g.leftGuide.anchor + 1, y: target.absolutePosition().y });\n                            drawGuide('vertical', g.leftGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        case isThirdXPosInGutter:\n                            target.absolutePosition({ x: g.leftGuide.anchor - targetRect.width, y: target.absolutePosition().y });\n                            drawGuide('vertical', g.leftGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        default:\n                            // if this switch statement is evaluating at least one of the above two OR conditions is true\n                            break;\n                    }\n                } else {\n                    var leftGuideLine = layer.children.find(x=> (x.name() === 'guid-line' && x.id() === 'vertical'+g.leftGuide.anchor));\n                    if(leftGuideLine) {leftGuideLine.destroy()}\n                }\n                // RIGHTGUIDE:\n                // snap to guideline gutter, and draw the guideline   \n                // target leftmost x point (should be 1 pixel more for right guide)\n                // OR target rightmost x point (should be 1 pixel less for left guide)\n                // else delete all guidelines\n                isFirstXPosInGutter = (g.rightGuide.startInterval < targetFirstXPos && targetFirstXPos < g.rightGuide.endInterval)\n                isThirdXPosInGutter = (g.rightGuide.startInterval < targetThirdXPos && targetThirdXPos < g.rightGuide.endInterval)\n                if (isFirstXPosInGutter || isThirdXPosInGutter) {\n                    // geometrically the two conditions must be exclusively (XOR) true    \n                    switch (true) {\n                        case isFirstXPosInGutter:\n                            // caution: if you use targetFirstXYPos instead target.absolutePosition() the target will no longer be clamped to the vertical guide\n                            target.absolutePosition({ x: g.rightGuide.anchor + 1, y: target.absolutePosition().y });\n                            drawGuide('vertical', g.rightGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        case isThirdXPosInGutter:\n                            target.absolutePosition({ x: g.rightGuide.anchor - targetRect.width, y: target.absolutePosition().y });\n                            drawGuide('vertical', g.rightGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        default:\n                            // if this switch statement is evaluating at least one of the above two OR conditions is true\n                            break;\n                    }\n                } else {\n                    var rightGuideLine = layer.children.find(x=> (x.name() === 'guid-line' && x.id() === 'vertical'+g.rightGuide.anchor));\n                    if(rightGuideLine) {rightGuideLine.destroy()}\n                }\n                // ABOVEGUIDE:\n                // snap to guideline gutter, and draw the guideline   \n                // target leftmost x point (should be 1 pixel more for right guide)\n                // OR target rightmost x point (should be 1 pixel less for left guide)\n                // else delete all guidelines\n                var isFirstYPosInGutter = (g.aboveGuide.startInterval < targetFirstYPos && targetFirstYPos < g.aboveGuide.endInterval)\n                var isThirdYPosInGutter = (g.aboveGuide.startInterval < targetThirdYPos && targetThirdYPos < g.aboveGuide.endInterval)\n                if (isFirstYPosInGutter || isThirdYPosInGutter) {\n                    // geometrically the two conditions must be exclusively (XOR) true\n                    switch (true) {\n                        case isFirstYPosInGutter:\n                            // caution: if you use targetFirstXYPos instead target.absolutePosition() the target will no longer be clamped to the vertical guide\n                            target.absolutePosition({ x: target.absolutePosition().x, y: g.aboveGuide.anchor + 1});\n                            drawGuide('horizontal', g.aboveGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        case isThirdYPosInGutter:\n                            target.absolutePosition({ x: target.absolutePosition().x, y: g.aboveGuide.anchor - targetRect.height});\n                            drawGuide('horizontal', g.aboveGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        default:\n                            // if this switch statement is evaluating at least one of the above two OR conditions is true\n                            break;\n                    }\n                } else {\n                    var aboveGuideLine = layer.children.find(x=> (x.name() === 'guid-line' && x.id() === 'horizontal'+g.aboveGuide.anchor));\n                    if(aboveGuideLine) {aboveGuideLine.destroy()};\n                }\n                // BELOWGUIDE:\n                // snap to guideline gutter, and draw the guideline   \n                // target leftmost x point (should be 1 pixel more for right guide)\n                // OR target rightmost x point (should be 1 pixel less for left guide)\n                // else delete all guidelines\n                var isFirstYPosInGutter = (g.belowGuide.startInterval < targetFirstYPos && targetFirstYPos < g.belowGuide.endInterval)\n                var isThirdYPosInGutter = (g.belowGuide.startInterval < targetThirdYPos && targetThirdYPos < g.belowGuide.endInterval)\n                if (isFirstYPosInGutter || isThirdYPosInGutter) {\n                    // geometrically the three conditions must be exclusively (XOR) true\n                    switch (true) {\n                        case isFirstYPosInGutter:\n                            // caution: if you use targetFirstXYPos instead target.absolutePosition() the target will no longer be clamped to the vertical guide\n                            target.absolutePosition({ x: target.absolutePosition().x, y: g.belowGuide.anchor + 1});\n                            drawGuide('horizontal', g.belowGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        case isThirdYPosInGutter:\n                            target.absolutePosition({ x: target.absolutePosition().x, y: g.belowGuide.anchor - targetRect.height});\n                            drawGuide('horizontal', g.belowGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        default:\n                            // if this switch statement is evaluating at least one of the above two OR conditions is true\n                            break;\n                    }\n                } else {\n                    var belowGuideLine = layer.children.find(x=> (x.name() === 'guid-line' && x.id() === 'horizontal'+g.belowGuide.anchor));\n                    if(belowGuideLine) {belowGuideLine.destroy()};\n                }\n            });\n        },\n        guideLines(target, layerChildren) {\n            // TODO: 0. destroy all guidelines from layer\n            var targetRect = target.findOne('Rect').getClientRect();\n            var targetFirstXPos = target.x();\n            var targetThirdXPos = target.x() + targetRect.width;\n\n            var targetFirstYPos = target.y();\n            var targetThirdYPos = target.y() + targetRect.height;\n\n            var cargoGroupArray = layerChildren.filter(x => (x.id() === 'cargoGroup' && !(x.attrs.cargoId === target.attrs.cargoId)))\n\n            var stage = this.$refs.stage.getStage()\n            var layer = this.$refs.layer.getNode().getLayer();\n\n            function drawGuide(orientation, anchorCoordinate) {\n                if (orientation == 'vertical') {\n                    var line = new Konva.Line({\n                        points: [anchorCoordinate, -6000, anchorCoordinate, 6000],\n                        stroke: 'rgb(0, 161, 255)',\n                        strokeWidth: 1,\n                        id: orientation + anchorCoordinate,\n                        name: 'guid-line',\n                        dash: [4, 6],\n                    });\n                    // if a line with the same orientation+anchorCoordinate id does not already exist then add it\n                    if(!layer.children.find(x=> (x.name() === 'guid-line' && x.id() === orientation+anchorCoordinate))){\n                        layer.add(line);\n                    }\n                } else { // orientation == 'horizontal'\n                    var line = new Konva.Line({\n                        points: [-6000, anchorCoordinate, 6000, anchorCoordinate],\n                        stroke: 'rgb(0, 161, 255)',\n                        strokeWidth: 1,\n                        id: orientation + anchorCoordinate,\n                        name: 'guid-line',\n                        dash: [4, 6],\n                    });\n                    // if a line with the same orientation+anchorCoordinate id does not already exist then add it\n                    if(!layer.children.find(x=> (x.name() === 'guid-line' && x.id() === orientation+anchorCoordinate))){\n                        layer.add(line);\n                    }\n\n                }\n            }\n            function generateGuidelineObject(kObj) {\n                var kObjRect = kObj.findOne('Rect').getClientRect()\n                var leftGuide = { \n                    startInterval: (kObj.x() - 5), \n                    endInterval: (kObj.x() + 5), \n                    anchor: kObj.x() - 1};\n                var rightGuide = {\n                    startInterval: (kObj.x() + kObjRect.width - 5),\n                    endInterval: (kObj.x() + kObjRect.width + 5),\n                    anchor: kObj.x() + kObjRect.width };\n                var aboveGuide = {\n                    startInterval: (kObj.y() - 5),\n                    endInterval: (kObj.y() + 5),\n                    anchor: kObj.y() - 1};\n                var belowGuide = {\n                    startInterval: (kObj.y() + kObjRect.height - 5),\n                    endInterval: (kObj.y() + kObjRect.height + 5),\n                    anchor: kObj.y() + kObjRect.height};\n\n                return { cargoId: kObj.attrs.cargoId, leftGuide: leftGuide, rightGuide: rightGuide, aboveGuide: aboveGuide, belowGuide: belowGuide };\n            }\n            var guideLinesArray = cargoGroupArray.map(x => generateGuidelineObject(x))\n            guideLinesArray.forEach(function (g) {\n                // LEFTGUIDE:\n                // snap to guideline gutter, and draw the guideline   \n                // target leftmost x point (should be 1 pixel more for right guide)\n                // OR target rightmost x point (should be 1 pixel less for left guide)\n                // else delete all guidelines\n                var isFirstXPosInGutter = (g.leftGuide.startInterval < targetFirstXPos && targetFirstXPos < g.leftGuide.endInterval)\n                var isThirdXPosInGutter = (g.leftGuide.startInterval < targetThirdXPos && targetThirdXPos < g.leftGuide.endInterval)\n                if (isFirstXPosInGutter || isThirdXPosInGutter) {\n                    // geometrically the two conditions must be exclusively (XOR) true    \n                    switch (true) {\n                        case isFirstXPosInGutter:\n                            // caution: if you use targetFirstXYPos instead target.absolutePosition() the target will no longer be clamped to the vertical guide\n                            target.position({ x: g.leftGuide.anchor + 1, y: target.y() });\n                            drawGuide('vertical', g.leftGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        case isThirdXPosInGutter:\n                            target.position({ x: g.leftGuide.anchor - targetRect.width, y: target.y() });\n                            drawGuide('vertical', g.leftGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        default:\n                            // if this switch statement is evaluating at least one of the above two OR conditions is true\n                            break;\n                    }\n                } else {\n                    var leftGuideLine = layer.children.find(x=> (x.name() === 'guid-line' && x.id() === 'vertical'+g.leftGuide.anchor));\n                    if(leftGuideLine) {leftGuideLine.destroy()}\n                }\n                // RIGHTGUIDE:\n                // snap to guideline gutter, and draw the guideline   \n                // target leftmost x point (should be 1 pixel more for right guide)\n                // OR target rightmost x point (should be 1 pixel less for left guide)\n                // else delete all guidelines\n                isFirstXPosInGutter = (g.rightGuide.startInterval < targetFirstXPos && targetFirstXPos < g.rightGuide.endInterval)\n                isThirdXPosInGutter = (g.rightGuide.startInterval < targetThirdXPos && targetThirdXPos < g.rightGuide.endInterval)\n                if (isFirstXPosInGutter || isThirdXPosInGutter) {\n                    // geometrically the two conditions must be exclusively (XOR) true    \n                    switch (true) {\n                        case isFirstXPosInGutter:\n                            // caution: if you use targetFirstXYPos instead target.absolutePosition() the target will no longer be clamped to the vertical guide\n                            target.position({ x: g.rightGuide.anchor + 1, y: target.y() });\n                            drawGuide('vertical', g.rightGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        case isThirdXPosInGutter:\n                            target.position({ x: g.rightGuide.anchor - targetRect.width, y: target.y() });\n                            drawGuide('vertical', g.rightGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        default:\n                            // if this switch statement is evaluating at least one of the above two OR conditions is true\n                            break;\n                    }\n                } else {\n                    var rightGuideLine = layer.children.find(x=> (x.name() === 'guid-line' && x.id() === 'vertical'+g.rightGuide.anchor));\n                    if(rightGuideLine) {rightGuideLine.destroy()}\n                }\n                // ABOVEGUIDE:\n                // snap to guideline gutter, and draw the guideline   \n                // target leftmost x point (should be 1 pixel more for right guide)\n                // OR target rightmost x point (should be 1 pixel less for left guide)\n                // else delete all guidelines\n                var isFirstYPosInGutter = (g.aboveGuide.startInterval < targetFirstYPos && targetFirstYPos < g.aboveGuide.endInterval)\n                var isThirdYPosInGutter = (g.aboveGuide.startInterval < targetThirdYPos && targetThirdYPos < g.aboveGuide.endInterval)\n                if (isFirstYPosInGutter || isThirdYPosInGutter) {\n                    // geometrically the two conditions must be exclusively (XOR) true\n                    switch (true) {\n                        case isFirstYPosInGutter:\n                            // caution: if you use targetFirstXYPos instead target.absolutePosition() the target will no longer be clamped to the vertical guide\n                            target.position({ x: target.x(), y: g.aboveGuide.anchor + 1});\n                            drawGuide('horizontal', g.aboveGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        case isThirdYPosInGutter:\n                            target.position({ x: target.x(), y: g.aboveGuide.anchor - targetRect.height});\n                            drawGuide('horizontal', g.aboveGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        default:\n                            // if this switch statement is evaluating at least one of the above two OR conditions is true\n                            break;\n                    }\n                } else {\n                    var aboveGuideLine = layer.children.find(x=> (x.name() === 'guid-line' && x.id() === 'horizontal'+g.aboveGuide.anchor));\n                    if(aboveGuideLine) {aboveGuideLine.destroy()};\n                }\n                // BELOWGUIDE:\n                // snap to guideline gutter, and draw the guideline   \n                // target leftmost x point (should be 1 pixel more for right guide)\n                // OR target rightmost x point (should be 1 pixel less for left guide)\n                // else delete all guidelines\n                var isFirstYPosInGutter = (g.belowGuide.startInterval < targetFirstYPos && targetFirstYPos < g.belowGuide.endInterval)\n                var isThirdYPosInGutter = (g.belowGuide.startInterval < targetThirdYPos && targetThirdYPos < g.belowGuide.endInterval)\n                if (isFirstYPosInGutter || isThirdYPosInGutter) {\n                    // geometrically the three conditions must be exclusively (XOR) true\n                    switch (true) {\n                        case isFirstYPosInGutter:\n                            // caution: if you use targetFirstXYPos instead target.absolutePosition() the target will no longer be clamped to the vertical guide\n                            target.position({ x: target.x(), y: g.belowGuide.anchor + 1});\n                            drawGuide('horizontal', g.belowGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        case isThirdYPosInGutter:\n                            target.position({ x: target.x(), y: g.belowGuide.anchor - targetRect.height});\n                            drawGuide('horizontal', g.belowGuide.anchor)\n                            stage.batchDraw()\n                            break;\n                        default:\n                            // if this switch statement is evaluating at least one of the above two OR conditions is true\n                            break;\n                    }\n                } else {\n                    var belowGuideLine = layer.children.find(x=> (x.name() === 'guid-line' && x.id() === 'horizontal'+g.belowGuide.anchor));\n                    if(belowGuideLine) {belowGuideLine.destroy()};\n                }\n            });\n        },\n        guideWalls(target, layerChildren, wallOverlap) {\n            //console.log(\"guideWalls Called\") //tmpdbg\n            var wallsArray = layerChildren.filter(x=>x.id()==='truckWall');\n            //If there are wall collisions, highlight the wall and return(? or highlight the appropriate border for intersected cargo), \n            //else set all walls to black and continue\n            // wallOverlap == [[Group, 797, 40, 'isWall'] \"rightWall\"]     !(el.id() === 'truckWall')\n            if(!(wallOverlap[1]===\"isNotWall\")){\n                var wallObj = layerChildren.find(x=>x.attrs.truckId === wallOverlap[1]);\n                wallObj.fill('red');\n                wallsArray.filter(x=>!(x.attrs.truckId === wallOverlap[1])).forEach(x=>x.fill('black'))\n            } else {\n                wallsArray.forEach(x=>x.fill('black'));\n            }\n        },\n        TESTING_guideWalls() {\n            // var layerChildren = this.$refs.layer.getNode().getLayer().children;\n            // var target = layerChildren.find(x => x.attrs.cargoId === 'cargo-1');\n            // this.guideLines(target, layerChildren)\n            var layerChildren = this.$refs.layer.getNode().getLayer().children;\n            var target = layerChildren.find(x=>x.attrs.cargoId === 'cargo-1');\n            this.guideWalls(target, layerChildren);\n        },\n\n        handleDragMove(event) {\n            // x left to right: pos 0 -> inf, y up to down: pos 0 -> inf, width, height\n            var target = event.target;\n            // If target is the the Layer which has id '' then do nothing\n            if (target.id() === ''){\n                return;\n            }\n\n            var targetRect = event.target.findOne('Rect').getClientRect();\n            //ensure truckFloor backing rectangle is not included in layerChildren\n            var layerChildren = this.$refs.layer.getNode().getLayer().children.filter(el=>!(el.id() === 'truckFloor'));\n            // draw guidelines\n            this.guideLines(target, layerChildren)\n            // collision.dprt(\"layerChildren monitoring: \", layerChildren) //tmpdbg\n            var wallOverlap = collision.processWallCollisions(target, target.x(), target.y(), layerChildren);\n            // [[Group, 797, 40, 'isWall'] \"rightWall\"]     !(el.id() === 'truckWall')\n            this.guideWalls(target, layerChildren, wallOverlap);\n\n\n            var cargoGroupArray = layerChildren.filter(x=>(x.id() === 'cargoGroup'  && \n                                                           !(x.attrs.cargoId === target.attrs.cargoId)))\n\n            // Intersection for all elements, not just those which intersect with target\n            var cargoGroupArrayIntersect =\n                cargoGroupArray.map(x=>[x, collision.haveIntersection([x, x.x(), x.y(),'isNotWall'], \n                                                                 x.findOne('Rect').getClientRect(),\n                                                                      targetRect, target.x(), target.y())]);\n            \n            target.findOne('Rect').opacity(0.5);\n            \n            cargoGroupArrayIntersect.forEach(\n                function (x) {\n                    var topBorder = x[0].findOne(x=>x.id() === 'topBorder');\n                    var bottomBorder = x[0].findOne(x=>x.id() === 'bottomBorder');\n                    var rightBorder = x[0].findOne(x=>x.id() === 'rightBorder');\n                    var leftBorder = x[0].findOne(x=>x.id() === 'leftBorder')\n                    if(x[1].intersectionResult) {\n                        switch(true) {\n                        // If a target cargo intersects a wall, then only highlight the collided cargo border parallel to that wall\n                        // If the collided cargo is outside the truck walls, highlight the opposite border\n                        //case (wallOverlap[1]==='backWall' || wallOverlap[1]==='isNotWall' && x[1].transform.y > 0):\n                        case (wallOverlap[1]===(this.isCargoOutside(layerChildren, target, x) ? 'frontWall' : 'backWall')\n                                || wallOverlap[1] === 'isNotWall' && x[1].transform.y > 0):\n                            topBorder.stroke('red');//\n                            topBorder.shadowEnabled(true);//\n                            bottomBorder.stroke('black');\n                            bottomBorder.shadowEnabled(false);\n                            rightBorder.stroke('black');\n                            rightBorder.shadowEnabled(false);\n                            leftBorder.stroke('black');\n                            leftBorder.shadowEnabled(false);\n                            break;\n                        //case (wallOverlap[1]==='isNotWall' && x[1].transform.y < 0):\n                        case (wallOverlap[1]===(this.isCargoOutside(layerChildren, target, x) ? 'backWall' : 'frontWall')\n                                || wallOverlap[1] === 'isNotWall' && x[1].transform.y < 0):\n                            topBorder.stroke('black');\n                            topBorder.shadowEnabled(false);\n                            bottomBorder.stroke('red');//\n                            bottomBorder.shadowEnabled(true);//\n                            rightBorder.stroke('black');\n                            rightBorder.shadowEnabled(false);\n                            leftBorder.stroke('black');\n                            leftBorder.shadowEnabled(false);\n                            break;\n                        case (wallOverlap[1]===(this.isCargoOutside(layerChildren, target, x) ? 'leftWall' : 'rightWall')\n                                || wallOverlap[1] === 'isNotWall' && x[1].transform.x < 0):\n                            topBorder.stroke('black');\n                            topBorder.shadowEnabled(false);\n                            bottomBorder.stroke('black');\n                            bottomBorder.shadowEnabled(false);\n                            rightBorder.stroke('red');\n                            rightBorder.shadowEnabled(true);\n                            leftBorder.stroke('black');\n                            leftBorder.shadowEnabled(false);\n                            break;\n                        case (wallOverlap[1]===(this.isCargoOutside(layerChildren, target, x) ? 'rightWall' : 'leftWall')\n                                || wallOverlap[1] === 'isNotWall' && x[1].transform.x > 0):\n                            topBorder.stroke('black');\n                            topBorder.shadowEnabled(false);\n                            bottomBorder.stroke('black');\n                            bottomBorder.shadowEnabled(false);\n                            rightBorder.stroke('black');\n                            rightBorder.shadowEnabled(false);\n                            leftBorder.stroke('red');\n                            leftBorder.shadowEnabled(true);\n                            break;\n                        }\n                    } else {\n                        topBorder.stroke('black');\n                        topBorder.shadowEnabled(false);\n                        bottomBorder.stroke('black');\n                        bottomBorder.shadowEnabled(false);\n                        rightBorder.stroke('black');\n                        rightBorder.shadowEnabled(false);\n                        leftBorder.stroke('black');\n                        leftBorder.shadowEnabled(false);\n                    }\n                }.bind(this))\n            // console.group(\"Transforms of cargo intersected with cargo-1\");\n            // console.log(JSON.stringify(cargoGroupArrayIntersect.map(x=>[x[0].attrs.cargoId, x[1].transform]), undefined, 2))\n            // console.groupEnd(\"Transforms of cargo intersected with cargo-1\");\n        },\n        handlePointerDown (event) {\n            event.target.getParent().moveToTop()\n            //console.log(event.target.getParent()); //tmpdbg\n        },\n        /* eslint-disable */ \n        // eslint disabled to ignore event declared but not used\n        handleDragEnd(event){\n            // event.target.attrs.cargoId\n            var target = event.target;\n            // If target is the the Layer which has id '' then do nothing\n            if (target.id() === ''){\n                // Return the layer to the bottom at the end of dragging or else the zoom buttons will be inaccessible\n                target.moveToBottom()\n                return;\n            }\n\n            \n            // clear all guidelines\n            var layer = this.$refs.layer.getNode().getLayer();\n            //collision.dprt(\"layerChildren before: \", layer.children) //tmpdbg\n            layer.find('.guid-line').forEach((l) => l.destroy())\n            //collision.dprt(\"layerChildren after: \", layer.children) //tmpdbg\n            \n\n            //ensure truckFloor backing rectangle is not included in layerChildren, but likely won't execute due to target as layer handled above\n            var layerChildren = layer.children.filter(el=>!(el.id() === 'truckFloor'));\n            var wallsArray = layerChildren.filter(x=>x.id()==='truckWall');\n            //clear wall highlighting\n            wallsArray.forEach(x=>x.fill('black'));\n            //reset borders and opacity\n            var cargoNoWallsArray = layerChildren.filter(el=> (!(el.id() === 'truckWall') && !(el.id() === 'truckFloor')));\n            cargoNoWallsArray.forEach(function(x){\n                x.findOne('Rect').opacity(1);            \n                var topBorder = x.findOne(x=>x.id() === 'topBorder');\n                var bottomBorder = x.findOne(x=>x.id() === 'bottomBorder');\n                var rightBorder = x.findOne(x=>x.id() === 'rightBorder');\n                var leftBorder = x.findOne(x=>x.id() === 'leftBorder');\n                topBorder.stroke('black');\n                topBorder.shadowEnabled(false);\n                bottomBorder.stroke('black');\n                bottomBorder.shadowEnabled(false);\n                rightBorder.stroke('black');\n                rightBorder.shadowEnabled(false);\n                leftBorder.stroke('black');\n                leftBorder.shadowEnabled(false);\n            })\n\n            // process collisions of target with environment\n            collision.pixelPush(target, layerChildren, this.saveStartDragCoords);\n\n\n        },\n        /* eslint-enable */  \n        // end tdd -------------------------------------------------------------------------------------------\n        // ---------------------------------------------------------------------------------------------------\n        mouseoverPointer () {\n            document.body.style.cursor = 'pointer';\n        },\n        mouseoutPointer () {\n            document.body.style.cursor = 'default';\n        },\n        addCargo(units, dimx, dimy) {\n            //console.log(\"Captured event with units: \" + units + \" dimx: \" + dimx + \" dimy: \" + dimy);\n            //Captured event with units: Imperial dimx: 48.00 dimy: 40.00\n            //Captured event with units: Metric dimx: 80.00 dimy: 120.00\n            //console.log(\"this.cargo before add:\"); //tmpdbg\n            //console.table(this.cargo); //tmpdbg\n            var cargoId = uniqueId(\"cargo-\")\n            this.cargo.push({id: cargoId,\n                             units: units,\n                             dimx: parseFloat(dimx),\n                             dimy: parseFloat(dimy),\n                             x: 0,\n                             y: 0,\n                            });\n            //console.log(\"this.cargo after add: \"); //tmpdbg\n            //console.table(this.cargo); //tmpdbg\n        },\n        loadSpaceSet(units, dimx, dimy){\n            //console.log(\"Captured event with units: \" + units + \" dimx: \" + dimx + \" dimy: \" + dimy);\n            //Captured event with units: Imperial dimx: 48.00 dimy: 40.00\n            //Captured event with units: Metric dimx: 80.00 dimy: 120.00\n            //console.log(\"this.truck before loadSpaceSet:\"); //tmpdbg\n            //console.table(this.truck); //tmpdbg\n            // truck: {units: \"Imperial\", originx: 500, originy: 10, dimx: 100, dimy: 200 }, \n            this.truck = {units: units,\n                          originx: this.truck.originx,\n                          originy: this.truck.originy,\n                          dimx: dimx,\n                          dimy: dimy,};\n            //console.log(\"this.truck after loadSpaceSet: \"); //tmpdbg\n            //console.table(this.truck); //tmpdbg\n            this.resizeStage();\n        },\n        deleteCargo(item, index) {\n            this.cargo.splice(index, 1);\n            //console.log(`deleteCargo rectangle clicked or tapped: index: ${index} id: ${item.id} dimx: ${item.dimx} dimy: ${item.dimy}`) //tmpdbg\n            this.mouseoutPointer(); // restore mouse pointer to default\n        },\n        deleteCargoCategory(drawerItem) {\n            //console.log(drawerItem); //tmpdbg\n            drawerItem.value.forEach(\n                function (cargoItem) {\n                    // console.log(\"cargoItem\"); //tmpdbg\n                    // console.log(cargoItem); //tmpdbg\n                    // console.log(\"this.cargo\"); //tmpdbg\n                    // console.log(this.cargo); //tmpdbg\n                    var foundIndex = this.cargo.findIndex(cargoEl=> (cargoEl.id === cargoItem.id));\n                    if (foundIndex > -1) {\n                        //console.log(\"cargoItem.id \" + cargoItem.id + \" was found at index \" + foundIndex ); //tmpdbg\n                        this.deleteCargo(cargoItem, foundIndex);\n                    }\n                }.bind(this));\n        },\n        deleteCargoCategoryItem(item) {\n            if (item['value'].length <= 1) {\n                //console.log(\"item['value'].length is : \" + item['value'].length + \"stop deleting\"); //tmpdbg\n                // console.log((\"the last value of item['value'] is : \"\n                //              + this.prObj(item['value'][item['value'].length - 1]) +\n                //              \" with id: \" + this.prObj(item['value'][item['value'].length - 1]['id']))); //tmpdbg\n                return;\n            } else {\n                // console.log(\"item['value'].length is : \" + item['value'].length);\n                // console.log((\"the last value of item['value'] is : \"\n                //             + this.prObj(item['value'][item['value'].length - 1]) +\n                //              \" with id: \" + this.prObj(item['value'][item['value'].length - 1]['id'])));\n                \n                var lastCargoCategoryItem =  item['value'][item['value'].length - 1];\n                var deleteCargoCategoryItemIndex = lastCargoCategoryItem['id'];\n                // console.log(this.prObj(this.cargo));\n                \n                var foundIndex = this.cargo.findIndex(cargoEl=> (cargoEl.id === deleteCargoCategoryItemIndex));\n                if (foundIndex > -1) {\n                    //console.log(\"lastCargoCategoryItem['id'] \" + lastCargoCategoryItem['id'] + \" was found at index \" + foundIndex); //tmpdbg\n                    this.deleteCargo(lastCargoCategoryItem, foundIndex);\n                }\n                \n            }\n        },\n        rotateCargo(item, index) {\n            //console.log(`rotateCargo rectangle clicked or tapped before: index: ${index} id: ${item.id} dimx: ${item.dimx} dimy: ${item.dimy}`) //tmpdbg\n            var tempdimx = this.cargo[index].dimx;\n            this.cargo[index].dimx = this.cargo[index].dimy;\n            this.cargo[index].dimy = tempdimx;\n            //console.log(`rotateCargo rectangle clicked or tapped after: index: ${index} id: ${item.id} dimx: ${item.dimx} dimy: ${item.dimy}`) //tmpdbg\n        },\n        /* eslint-enable */\n        resizeStage() {\n            var stage = this.$refs.stage.getStage()\n            var parentOfContainerWidth = document.getElementById(\"container\").parentNode.offsetWidth;\n            \n            stage.width(parentOfContainerWidth);\n            stage.height(window.innerHeight*2);\n            this.truck.originx = this.truckLocationX();\n            \n            //console.log(\"resize has occured stage width: \" + stage.width() + \" stage height: \" + stage.height() ); //tmpdbg\n        },\n        truckLocationX() {\n            // var parentOfContainerWidth = document.getElementById(\"container\").parentNode.offsetWidth;\n            // var parentOfContainerHeight = document.getElementById(\"container\").parentNode.offsetHeight;\n            var stage = this.$refs.stage.getStage()\n            var stageWidth = stage.width()\n            //             truck: {units: \"Imperial\", originx: 500, originy: 10, dimx: 102, dimy: 576 },\n            // width: this.truck.units === 'Imperial' ?  this.truck.dimx * scaleFactor : this.truck.dimx * 0.3937 * scaleFactor,\n            var truckWidth;\n            if (this.truck.units === \"Imperial\") {\n                truckWidth = this.truck.dimx * this.scaleFactor;\n                // return \"stageWidth: \" + stageWidth + \" truckWidth: \" + truckWidth\n                //     + \" Math.round((stageWidth - truckWidth)/2): \" + Math.round((stageWidth - truckWidth)/2);\n                return Math.round((stageWidth - (truckWidth + 20))/2)\n                //return [JSON.stringify(this.truck), this.scaleFactor, \"IMPERIAL\", truckWidth, stageWidth, parentOfContainerWidth];\n            } else {\n                truckWidth = this.truck.dimx * 0.3937 * this.scaleFactor;\n                // return \"stageWidth: \" + stageWidth + \" truckWidth: \" + truckWidth\n                //             + \" Math.round((stageWidth - truckWidth)/2): \" + Math.round((stageWidth - truckWidth)/2);\n                return Math.round((stageWidth - (truckWidth + 20))/2)\n                //return [JSON.stringify(this.truck), this.scaleFactor, \"METRIC\", truckWidth, stageWidth, parentOfContainerWidth];\n            }\n        },\n        lowestYBound () {\n            //console.log(this.$refs.layer.getNode().getLayer().children); //tmpdbg\n            this.$refs.layer.getNode().getLayer().children.forEach(\n                function (el) {\n                    if (el.id() === \"cargoGroup\") {\n                        // console.log(\"data?: \" + el.attrs.cargoId + \"el.id: \" + el.id() +  \" y value: \" + el.y() +  \" height: \"\n                        //             + el.findOne('Rect').getClientRect().height); //tmpdbg\n                    }\n                }\n            );\n            var allChildren = this.$refs.layer.getNode().getLayer().children;\n            var cargoGroupElements = allChildren.filter(el => el.id() === \"cargoGroup\")\n            var lowestYBound = cargoGroupElements.map((el)=>el.y() + el.findOne('Rect').getClientRect().height);\n            //console.log(lowestYBound); //tmpdbg\n            return Math.max(...lowestYBound, 0)+1;\n        },\n    },\n    computed: {\n        generateNavDrawerList () {\n            var groupedCargo = groupBy(this.cargo, (cargo)=>[cargo.units, cargo.dimx, cargo.dimy]);\n            var groupedCargoArrayStr = Object.entries(groupedCargo).map(element => [element[0].split(\",\"), element[1]]);\n            var groupedCargoArray = Object.entries(groupedCargoArrayStr).map(element =>\n                                                                             [[element[1][0][0], parseInt(element[1][0][1]), parseInt(element[1][0][2])], element[1][1]]);\n            var orderedGroupedCargoArray = (orderBy(groupedCargoArray, [(el)=>el[0][0], (el)=>el[0][1], (el)=>el[0][2], ['asc', 'asc', 'asc']]))\n            var navDrawerListArray =\n                orderedGroupedCargoArray.map(\n                    (el)=> ({title : `${el[0][1]}${el[0][0] === 'Imperial' ? 'in' : 'cm'} x ${el[0][2]}${el[0][0] === 'Imperial' ? 'in' : 'cm'}`,\n                             value : el[1]}));\n            return navDrawerListArray;\n            // console.log(this.prObj(navDrawerListArray)); \n            // [{\"title\": \"42in x 42in\",\n            //   \"value\": [{\"id\": \"cargo-3\", \"units\": \"Imperial\", \"dimx\": 42, \"dimy\": 42}]},\n            //  {\"title\": \"48in x 40in\",\n            //   \"value\": [{\"id\": \"cargo-1\", \"units\": \"Imperial\", \"dimx\": 48, \"dimy\": 40},\n            //             {\"id\": \"cargo-2\", \"units\": \"Imperial\", \"dimx\": 48, \"dimy\": 40}]},\n            //  {\"title\": \"48in x 48in\",\n            //   \"value\": [{\"id\": \"cargo-4\", \"units\": \"Imperial\", \"dimx\": 48, \"dimy\": 48}]},\n            //  {\"title\": \"80cm x 60cm\",\n            //   \"value\": [{\"id\": \"cargo-8\", \"units\": \"Metric\", \"dimx\": 80, \"dimy\": 60}]},\n            //  {\"title\": \"80cm x 120cm\",\n            //   \"value\": [{\"id\": \"cargo-5\", \"units\": \"Metric\", \"dimx\": 80, \"dimy\": 120},\n            //             {\"id\": \"cargo-6\", \"units\": \"Metric\", \"dimx\": 80, \"dimy\": 120}]},\n            //  {\"title\": \"120cm x 100cm\",\n            //   \"value\": [{\"id\": \"cargo-7\", \"units\": \"Metric\", \"dimx\": 120, \"dimy\": 100}]}]\n\n\n\n\n\n            \n        },\n    },\n    watch: {\n      group () {\n        this.drawer = false\n      },\n    },\n};\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\nh3 {\n    margin: 40px 0 0;\n}\nul {\n    list-style-type: none;\n    padding: 0;\n}\nli {\n    display: inline-block;\n    margin: 0 10px;\n}\na {\n    color: #42b983;\n}\n\n</style>\n\n\n","<template>\r\n\r\n\r\n<v-dialog v-model=\"dialog\" :width=\"displayWidth\">\r\n  <template v-slot:activator=\"{ props }\">\r\n    <v-btn v-if=\"mobileOrDesktop==='desktop'\"\r\n      prepend-icon=\"mdi-forklift\" :color=\"customColor\"\r\n      :class=\"customClasses\" :block=\"blockStyle\" :variant=\"variantStyle\"\r\n      :style=\"customStyle\"\r\n      v-bind=\"props\">\r\n      Add Cargo </v-btn>\r\n    <v-btn v-else\r\n      icon=\"mdi-forklift\" :color=\"customColor\"\r\n      class=\"my-2\" :block=\"blockStyle\"\r\n      v-bind=\"props\"> </v-btn>\r\n  </template>\r\n  \r\n  <v-card>\r\n    <v-card-title class=\"text-h5\"> Add Cargo </v-card-title>\r\n    <v-form ref=\"addCargoForm\" @submit.prevent=\"onSubmit\">\r\n      <v-container>\r\n        <v-row>\r\n          <v-col>\r\n            <v-select\r\n              label=\"Select Metric (cm) or Imperial (in) Units\"\r\n              v-model=\"selectedUnits\"\r\n              :items=\"unitChoice\"\r\n              item-title=\"desc\"\r\n              item-value=\"unit\"\r\n              @update:modelValue=\"newUnitSelected()\"\r\n              return-object\r\n              ></v-select>\r\n            \r\n          </v-col>\r\n        </v-row>\r\n        <v-row>\r\n          <v-col>\r\n            <v-text-field\r\n              v-model=\"dimx\"\r\n              @change=\"dimx = Number.parseFloat(dimx).toFixed(2).toString()\"\r\n              :label=\"(this.selectedUnits.unit === 'Metric') ? 'Width (cm)' : 'Width (in)'\"\r\n              :suffix=\"(this.selectedUnits.unit === 'Metric') ? 'cm' : 'in'\"\r\n              :rules=\"dimRules\"\r\n              validate-on=\"input\"\r\n              ></v-text-field>\r\n          </v-col>\r\n          <v-col>\r\n            <v-text-field\r\n              v-model=\"dimy\"\r\n              @change=\"dimy = Number.parseFloat(dimy).toFixed(2).toString()\"\r\n              :label=\"(this.selectedUnits.unit === 'Metric') ? 'Length (cm)' : 'Length (in)'\"\r\n              :suffix=\"(this.selectedUnits.unit === 'Metric') ? 'cm' : 'in'\"\r\n              :rules=\"dimRules\"\r\n              ></v-text-field>\r\n          </v-col>\r\n        </v-row>\r\n        \r\n        <v-row>\r\n          <v-col>\r\n            <v-select\r\n              v-if=\"selectedUnits.unit === 'Metric'\"\r\n              label=\"Metric Pallet Sizes (centimetres)\"\r\n              v-model=\"metricPallet\"\r\n              :items=\"metricPalletSizes\"\r\n              item-title=\"desc\"\r\n              item-value=\"tuple\"\r\n              @update:modelValue=\"newMetricPalletSelected()\"\r\n              return-object\r\n              ></v-select>\r\n            \r\n            <v-select\r\n              v-else\r\n              label=\"Imperial Pallet Sizes (inches)\"\r\n              v-model=\"imperialPallet\"\r\n              :items=\"imperialPalletSizes\"\r\n              item-title=\"desc\"\r\n              item-value=\"tuple\"\r\n              @update:modelValue=\"newImperialPalletSelected()\"\r\n              return-object\r\n              ></v-select>\r\n          </v-col>\r\n        </v-row>\r\n        \r\n        \r\n        \r\n      </v-container>\r\n    </v-form>\r\n    \r\n    <v-card-actions>\r\n      <v-spacer></v-spacer>\r\n      <v-btn color=\"success\" @click=\"onSubmit\"> Submit </v-btn>\r\n      <v-btn color=\"error\" @click=\"dialog = false\"> Cancel </v-btn>\r\n    </v-card-actions>\r\n  </v-card>\r\n</v-dialog>\r\n\r\n</template>\r\n\r\n<script>\r\nimport { computed } from 'vue'\r\nimport { useDisplay } from 'vuetify'\r\n  \r\nexport default {\r\n    customColor: \"\",\r\n    customClasses: \"\",\r\n    blockStyle: false,\r\n    variantStyle: \"\",\r\n    customStyle: \"\",\r\n    mobileOrDesktop: \"desktop\",\r\n    props:\r\n    {\r\n        customColor: String,\r\n        customClasses: String,\r\n        blockStyle: Boolean,\r\n        variantStyle: String,\r\n        customStyle: Object,\r\n        mobileOrDesktop: String,\r\n    },\r\n    setup () {\r\n        \r\n        const { name } = useDisplay()\r\n        \r\n        const displayWidth = computed(() => {\r\n            // console.log(name.value);\r\n            // name is reactive and\r\n            // must use .value\r\n            switch (name.value) {\r\n            case 'xs':\r\n            case 'sm': return \"100vw\"\r\n            case 'md': \r\n            case 'lg': \r\n            case 'xl': \r\n            case 'xxl': return \"40vw\"\r\n            default: return \"100vw\"\r\n            }\r\n        })\r\n        \r\n        return { displayWidth }\r\n    },\r\n    \r\n    data() {\r\n        return {\r\n            // use type coercion to parse the _entirety_ of the string (`parseFloat` alone does not do this)...\r\n            // ...and ensure strings of whitespace fail\r\n            dimRules: [\r\n                value => {\r\n                    if (value) return true\r\n                    return \"Dimension is required.\"},\r\n                value => {\r\n                    if(!isNaN(value) && !isNaN(parseFloat(value))) return true\r\n                    return \"Dimension must be a number.\"}],\r\n            \r\n            selectedUnits: { desc: 'Imperial (inches)', unit: 'Imperial' },\r\n            unitChoice: [\r\n                { desc: 'Metric (centimetres)', unit: 'Metric' },\r\n                { desc: 'Imperial (inches)', unit: 'Imperial' },\r\n            ],\r\n            metricPallet: { desc: 'EUR 1 80cm x 120cm', tuple: [\"80.00\", \"120.00\"] },\r\n            metricPalletSizes: [\r\n                { desc: 'EUR 1 80cm x 120cm', tuple: [\"80.00\", \"120.00\"] },\r\n                { desc: 'EUR 2 120cm x 100cm', tuple: [\"120.00\", \"100.00\"] },\r\n                { desc: 'EUR 3 100cm x 120cm', tuple: [\"100.00\", \"120.00\"] },\r\n                { desc: 'EUR 6 80cm x 60cm', tuple: [\"80.00\", \"60.00\"] },\r\n            ],\r\n            imperialPallet: { desc: '48\" x 40\"', tuple: [\"48.00\", \"40.00\"] },\r\n            imperialPalletSizes: [\r\n                { desc: '48\" x 40\"', tuple: [\"48.00\", \"40.00\"] },\r\n                { desc: '42\" x 42\"', tuple: [\"42.00\", \"42.00\"] },\r\n                { desc: '48\" x 48\"', tuple: [\"48.00\", \"48.00\"] }\r\n            ],\r\n            dimx: \"48.00\",\r\n            dimy: '40.00',\r\n            dialog: false,\r\n        };\r\n    },\r\n    \r\n    methods: {\r\n        newUnitSelected() {\r\n            if (this.selectedUnits.unit === \"Metric\") {\r\n                this.dimx=this.metricPallet.tuple[0];\r\n                this.dimy=this.metricPallet.tuple[1];\r\n            }\r\n            else {\r\n                this.dimx=this.imperialPallet.tuple[0];\r\n                this.dimy=this.imperialPallet.tuple[1];\r\n            }\r\n        },\r\n        newMetricPalletSelected() {\r\n            this.dimx=this.metricPallet.tuple[0];\r\n            this.dimy=this.metricPallet.tuple[1];\r\n        },\r\n        newImperialPalletSelected() {\r\n            this.dimx=this.imperialPallet.tuple[0];\r\n            this.dimy=this.imperialPallet.tuple[1];\r\n        },\r\n        onSubmit() {\r\n            this.$emit('cargo-added', this.selectedUnits.unit, this.dimx, this.dimy);\r\n            //this.$refs.addCargoForm.reset(); //fails\r\n            this.$refs.addCargoForm.resetValidation(); //works!\r\n            this.dialog=false;\r\n        },\r\n    },\r\n};\r\n</script>\r\n\r\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\r\n<style scoped>\r\nh3 {\r\n    margin: 40px 0 0;\r\n}\r\nul {\r\n    list-style-type: none;\r\n    padding: 0;\r\n}\r\nli {\r\n    display: inline-block;\r\n    margin: 0 10px;\r\n}\r\na {\r\n    color: #42b983;\r\n}\r\n\r\n</style>\r\n\r\n\r\n","import { render } from \"./AddDialog.vue?vue&type=template&id=4bf83775&scoped=true\"\nimport script from \"./AddDialog.vue?vue&type=script&lang=js\"\nexport * from \"./AddDialog.vue?vue&type=script&lang=js\"\n\nimport \"./AddDialog.vue?vue&type=style&index=0&id=4bf83775&scoped=true&lang=css\"\n\nimport exportComponent from \"../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-4bf83775\"]])\n\nexport default __exports__","<template>\r\n\r\n\r\n<v-dialog v-model=\"dialog\" :width=\"displayWidth\">\r\n  <template v-slot:activator=\"{ props }\">\r\n    <v-btn v-if=\"mobileOrDesktop==='desktop'\"\r\n      prepend-icon=\"mdi-truck-outline\"  :color=\"customColor\"\r\n      :class=\"customClasses\" :block=\"blockStyle\" :variant=\"variantStyle\"\r\n      :style=\"customStyle\"\r\n      v-bind=\"props\">\r\n      Set Loading Space </v-btn>\r\n    <v-btn v-else\r\n      icon=\"mdi-truck-outline\"  :color=\"customColor\"\r\n      class=\"my-2\" :block=\"blockStyle\"\r\n      v-bind=\"props\"></v-btn>\r\n  </template>\r\n  \r\n  <v-card>\r\n    <v-card-title class=\"text-h5\"> Set Loading Space </v-card-title>\r\n    <v-form ref=\"setTruckSizeForm\" @submit.prevent=\"onSubmit\">\r\n      <v-container>\r\n        <v-row>\r\n          <v-col>\r\n            <v-select\r\n              label=\"Select Metric (cm) or Imperial (in) Units\"\r\n              v-model=\"selectedUnits\"\r\n              :items=\"unitChoice\"\r\n              item-title=\"desc\"\r\n              item-value=\"unit\"\r\n              @update:modelValue=\"newUnitSelected()\"\r\n              return-object\r\n              ></v-select>\r\n            \r\n          </v-col>\r\n        </v-row>\r\n        <v-row>\r\n          <v-col>\r\n            <v-text-field\r\n              v-model=\"dimx\"\r\n              @change=\"dimx = Number.parseFloat(dimx).toFixed(2).toString()\"\r\n              :label=\"(this.selectedUnits.unit === 'Metric') ? 'Width (cm)' : 'Width (in)'\"\r\n              :suffix=\"(this.selectedUnits.unit === 'Metric') ? 'cm' : 'in'\"\r\n              :rules=\"dimRules\"\r\n              validate-on=\"input\"\r\n              ></v-text-field>\r\n          </v-col>\r\n          <v-col>\r\n            <v-text-field\r\n              v-model=\"dimy\"\r\n              @change=\"dimy = Number.parseFloat(dimy).toFixed(2).toString()\"\r\n              :label=\"(this.selectedUnits.unit === 'Metric') ? 'Length (cm)' : 'Length (in)'\"\r\n              :suffix=\"(this.selectedUnits.unit === 'Metric') ? 'cm' : 'in'\"\r\n              :rules=\"dimRules\"\r\n              ></v-text-field>\r\n          </v-col>\r\n        </v-row>\r\n        \r\n        <v-row>\r\n          <v-col>\r\n            <v-select\r\n              v-if=\"selectedUnits.unit === 'Metric'\"\r\n              label=\"Loading Spaces (centimetres)\"\r\n              v-model=\"metricLoadingSpace\"\r\n              :items=\"metricLoadingSpaceSizes\"\r\n              item-title=\"desc\"\r\n              item-value=\"tuple\"\r\n              @update:modelValue=\"newMetricPalletSelected()\"\r\n              return-object\r\n              ></v-select>\r\n            \r\n            <v-select\r\n              v-else\r\n              label=\"Loading Spaces (inches)\"\r\n              v-model=\"imperialLoadingSpace\"\r\n              :items=\"imperialLoadingSpaceSizes\"\r\n              item-title=\"desc\"\r\n              item-value=\"tuple\"\r\n              @update:modelValue=\"newImperialPalletSelected()\"\r\n              return-object\r\n              ></v-select>\r\n          </v-col>\r\n        </v-row>\r\n        \r\n        \r\n        \r\n      </v-container>\r\n    </v-form>\r\n    \r\n    <v-card-actions>\r\n      <v-spacer></v-spacer>\r\n      <v-btn color=\"success\" @click=\"onSubmit\"> Submit </v-btn>\r\n      <v-btn color=\"error\" @click=\"dialog = false\"> Cancel </v-btn>\r\n    </v-card-actions>\r\n  </v-card>\r\n</v-dialog>\r\n\r\n</template>\r\n\r\n<script>\r\n  import { computed } from 'vue'\r\n  import { useDisplay } from 'vuetify'\r\n\r\nexport default {\r\n    customColor: \"\",\r\n    customClasses: \"\",\r\n    blockStyle: false,\r\n    variantStyle: \"\",\r\n    customStyle: \"\",\r\n    mobileOrDesktop: \"desktop\",\r\n    props:\r\n    {\r\n        customColor: String,\r\n        customClasses: String,\r\n        blockStyle: Boolean,\r\n        variantStyle: String,\r\n        customStyle: Object,\r\n        mobileOrDesktop: String,\r\n    },\r\n    setup () {\r\n        const { name } = useDisplay()\r\n        \r\n        const displayWidth = computed(() => {\r\n            // console.log(name.value);\r\n            // name is reactive and\r\n            // must use .value\r\n            switch (name.value) {\r\n            case 'xs':\r\n            case 'sm': return \"100vw\"\r\n            case 'md': \r\n            case 'lg': \r\n            case 'xl': \r\n            case 'xxl': return \"40vw\"\r\n            default: return \"100vw\"\r\n            }\r\n        })\r\n        \r\n        return { displayWidth }\r\n    },\r\n    \r\n    data() {\r\n        return {\r\n            // use type coercion to parse the _entirety_ of the string (`parseFloat` alone does not do this)...\r\n            // ...and ensure strings of whitespace fail\r\n            dimRules: [\r\n                value => {\r\n                    if (value) return true\r\n                    return \"Dimension is required.\"},\r\n                value => {\r\n                    if(!isNaN(value) && !isNaN(parseFloat(value))) return true\r\n                    return \"Dimension must be a number.\"}],\r\n            \r\n            selectedUnits: { desc: 'Imperial (inches)', unit: 'Imperial' },\r\n            unitChoice: [\r\n                { desc: 'Metric (centimetres)', unit: 'Metric' },\r\n                { desc: 'Imperial (inches)', unit: 'Imperial' },\r\n            ],\r\n            metricLoadingSpace: { desc: 'Box Trailer 246cm x 1350cm', tuple: [\"246.00\", \"1350.00\"] },\r\n            metricLoadingSpaceSizes: [\r\n                { desc: 'Box Trailer 246cm x 1350cm', tuple: [\"246.00\", \"1350.00\"] },\r\n                { desc: 'Mega Trailer 247cm x 1360cm', tuple: [\"247.00\", \"1360.00\"] },\r\n                { desc: 'Refridgerated Trailer 249cm x 1341cm', tuple: [\"249.00\", \"1341.00\"] },\r\n                { desc: 'Single Truck Unit 250cm x 800cm', tuple: [\"250.00\", \"800.00\"] },\r\n            ],\r\n            imperialLoadingSpace: { desc: 'Flatbed Trailer 102\" (8.5ft) x 576\" (48ft)',   tuple: [\"102.00\", \"576.00\"] },\r\n            imperialLoadingSpaceSizes: [\r\n                { desc: 'Flatbed Trailer 102\" (8.5ft) x 576\" (48ft)',   tuple: [\"102.00\", \"576.00\"] },\r\n                { desc: 'Flatbed Trailer 96\" (8ft) x 576\" (48ft)',      tuple: [\"96.00\",  \"576.00\"] },\r\n                { desc: 'Container Chassis 102\" (8.5ft) x 240\" (48ft)', tuple: [\"102.00\", \"240.00\"] },\r\n                { desc: 'Container Chassis 96\" (8ft) x 240\" (48ft)',    tuple: [\"96.00\", \"240.00\"] },\r\n            ],\r\n            dimx: \"102.00\",\r\n            dimy: '576.00',\r\n            dialog: false,\r\n        };\r\n    },\r\n    \r\n    methods: {\r\n        newUnitSelected() {\r\n            if (this.selectedUnits.unit === \"Metric\") {\r\n                this.dimx=this.metricLoadingSpace.tuple[0];\r\n                this.dimy=this.metricLoadingSpace.tuple[1];\r\n            }\r\n            else {\r\n                this.dimx=this.imperialLoadingSpace.tuple[0];\r\n                this.dimy=this.imperialLoadingSpace.tuple[1];\r\n            }\r\n        },\r\n        newMetricPalletSelected() {\r\n            this.dimx=this.metricLoadingSpace.tuple[0];\r\n            this.dimy=this.metricLoadingSpace.tuple[1];\r\n        },\r\n        newImperialPalletSelected() {\r\n            this.dimx=this.imperialLoadingSpace.tuple[0];\r\n            this.dimy=this.imperialLoadingSpace.tuple[1];\r\n        },\r\n        onSubmit() {\r\n            this.$emit('load-space-set', this.selectedUnits.unit, this.dimx, this.dimy);\r\n            //this.$refs.addCargoForm.reset(); //fails\r\n            this.$refs.setTruckSizeForm.resetValidation(); //works!\r\n            this.dialog=false;\r\n        },\r\n    },\r\n};\r\n</script>\r\n\r\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\r\n<style scoped>\r\nh3 {\r\n    margin: 40px 0 0;\r\n}\r\nul {\r\n    list-style-type: none;\r\n    padding: 0;\r\n}\r\nli {\r\n    display: inline-block;\r\n    margin: 0 10px;\r\n}\r\na {\r\n    color: #42b983;\r\n}\r\n\r\n</style>\r\n\r\n\r\n","import { render } from \"./TruckDialog.vue?vue&type=template&id=41d7d97d&scoped=true\"\nimport script from \"./TruckDialog.vue?vue&type=script&lang=js\"\nexport * from \"./TruckDialog.vue?vue&type=script&lang=js\"\n\nimport \"./TruckDialog.vue?vue&type=style&index=0&id=41d7d97d&scoped=true&lang=css\"\n\nimport exportComponent from \"../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-41d7d97d\"]])\n\nexport default __exports__","<template>\n<v-group\n  ref=\"cargoGroupRef\"\n  :config=\"{id: 'cargoGroup', \n           draggable: true,\n           }\"\n  :cargoId=\"item.id\">\n  \n  <v-rect\n    :config=\"{\n             id: 'cargoGroup',\n             x: 0,\n             y: 0,\n             width: item.units === 'Imperial' ? item.dimx * scaleFactor : Math.floor(item.dimx * 0.3937 * scaleFactor),\n             height: item.units === 'Imperial' ? (item.dimy) * scaleFactor : Math.floor(item.dimy * 0.3937 * scaleFactor),\n             fill: 'yellow',\n             strokeWidth: 1,\n             stroke: 'black',\n             }\"\n    />\n\n  <!-- old text with pixel coordinates: //tmpdbg\n  text: `${item.x} x ${item.y}\\n${item.id}\\n${item.dimx}${item.units === 'Imperial' ? 'in' : 'cm'} x ${item.dimy}${item.units === 'Imperial' ? 'in' : 'cm'}`, -->\n  <v-text\n    :config=\"{\n             x: 0,\n             y: 0,\n             text: `${item.id}\\n${item.dimx}${item.units === 'Imperial' ? 'in' : 'cm'} x ${item.dimy}${item.units === 'Imperial' ? 'in' : 'cm'}`,\n             fontFamily: 'Georgia',\n             fontSize: 7*scaleFactor,\n             fill: 'black',\n             wrap: 'none',\n             width: item.units === 'Imperial' ? Math.max(50*scaleFactor, (item.dimx) * scaleFactor) : Math.max(50*scaleFactor, (item.dimx) * 0.3937 * scaleFactor),\n             height: item.units === 'Imperial' ? (item.dimy) * scaleFactor : (item.dimy) * 0.3937 * scaleFactor,\n             align: 'center',\n             verticalAlign: 'middle'\n             }\"\n    />\n  \n  <!-- old width and height //tmpdbg\n             width: (item.units === 'Imperial') ? Math.max(5, .005 * (item.dimx*item.dimy) * scaleFactor) : Math.max(5, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor),\n             height: (item.units === 'Imperial') ?  Math.max(5, .005 * (item.dimx*item.dimy) * scaleFactor) : Math.max(5, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor),\n             fillPatternImage: this.closeIcon,\n             fillPatternScaleX: (item.units === 'Imperial') ? Math.max(5, .005 * (item.dimx*item.dimy) * scaleFactor)/16 : Math.max(5, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor)/16,\n             fillPatternScaleY: (item.units === 'Imperial') ?  Math.max(5, .005 * (item.dimx*item.dimy) * scaleFactor)/16 : Math.max(5, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor)/16,\n  -->\n  <v-rect\n    @tap=\"$emit('deleteCargo', item, index)\"\n    @click=\"$emit('deleteCargo', item, index)\"\n    @mouseover=\"mouseoverPointer\"\n    @mouseout=\"mouseoutPointer\"\n    :config=\"{\n             x: 0,\n             y: 0,\n             width: (item.units === 'Imperial') ? Math.max(16, .005 * (item.dimx*item.dimy) * scaleFactor) : Math.max(16, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor),\n             height: (item.units === 'Imperial') ?  Math.max(16, .005 * (item.dimx*item.dimy) * scaleFactor) : Math.max(16, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor),\n             fillPatternImage: this.closeIcon,\n             fillPatternScaleX: (item.units === 'Imperial') ? Math.max(16, .005 * (item.dimx*item.dimy) * scaleFactor)/16 : Math.max(16, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor)/16,\n             fillPatternScaleY: (item.units === 'Imperial') ?  Math.max(16, .005 * (item.dimx*item.dimy) * scaleFactor)/16 : Math.max(16, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor)/16,\n             }\"\n    />\n\n  <!-- old width and height //tmpdbg\n  width: (item.units === 'Imperial') ? Math.max(5, .005 * (item.dimx*item.dimy) * scaleFactor) : Math.max(5, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor),\n  height: (item.units === 'Imperial') ? Math.max(5, .005 * (item.dimx*item.dimy) * scaleFactor) : Math.max(5, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor),\n  fillPatternImage: rotateIcon,\n  fillPatternScaleX: (item.units === 'Imperial') ? Math.max(5, .005 * (item.dimx*item.dimy) * scaleFactor)/16 : Math.max(5, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor)/16,\n  fillPatternScaleY: (item.units === 'Imperial') ? Math.max(5, .005 * (item.dimx*item.dimy) * scaleFactor)/16 : Math.max(5, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor)/16, \n  -->\n  <v-rect\n    @tap=\"$emit('rotateCargo', item, index)\"\n    @click=\"$emit('rotateCargo', item, index)\"\n    @mouseover=\"mouseoverPointer\"\n    @mouseout=\"mouseoutPointer\"\n    :config=\"{\n             x:(item.units === 'Imperial') ?  ((item.dimx) * scaleFactor) - Math.max(16, 0.005 * (item.dimx*item.dimy) * scaleFactor) \n             : ((item.dimx) * 0.3937 * scaleFactor) - Math.max(16, 0.005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor),\n             y: 0,\n             width: (item.units === 'Imperial') ? Math.max(16, .005 * (item.dimx*item.dimy) * scaleFactor) : Math.max(16, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor),\n             height: (item.units === 'Imperial') ?  Math.max(16, .005 * (item.dimx*item.dimy) * scaleFactor) : Math.max(16, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor),\n             fillPatternImage: rotateIcon,\n             fillPatternScaleX: (item.units === 'Imperial') ? Math.max(16, .005 * (item.dimx*item.dimy) * scaleFactor)/16 : Math.max(16, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor)/16,\n             fillPatternScaleY: (item.units === 'Imperial') ?  Math.max(16, .005 * (item.dimx*item.dimy) * scaleFactor)/16 : Math.max(16, .005 * (item.dimx*0.3937*item.dimy*0.3937) * scaleFactor)/16,\n             }\"\n    />\n  <v-line\n    :config=\"{\n             id: 'topBorder',\n             points: [0,0,item.units === 'Imperial' ? item.dimx * scaleFactor : item.dimx * 0.3937 * scaleFactor,0],\n             strokeWidth: 2,\n             stroke: 'black',\n             shadowColor: 'red',\n             shadowBlur: 10,\n             shadowEnabled: false,\n             }\"\n    />\n\n  <v-line\n    :config=\"{\n             id: 'bottomBorder',\n             points: [0,\n                      item.units === 'Imperial' ? (item.dimy) * scaleFactor : (item.dimy) * 0.3937 * scaleFactor,\n                      item.units === 'Imperial' ? item.dimx * scaleFactor : item.dimx * 0.3937 * scaleFactor,\n                      item.units === 'Imperial' ? (item.dimy) * scaleFactor : (item.dimy) * 0.3937 * scaleFactor],\n             strokeWidth: 2,\n             stroke: 'black',\n             shadowColor: 'red',\n             shadowBlur: 10,\n             shadowEnabled: false,\n             }\"\n    />\n\n  <v-line\n    :config=\"{\n             id: 'leftBorder',\n             points: [0,\n                      0,\n                      0,\n                      item.units === 'Imperial' ? (item.dimy) * scaleFactor : (item.dimy) * 0.3937 * scaleFactor],\n             strokeWidth: 2,\n             stroke: 'black',\n             shadowColor: 'red',\n             shadowBlur: 10,\n             shadowEnabled: false,\n             }\"\n    />\n\n  <v-line\n    :config=\"{\n             id: 'rightBorder',\n             points: [item.units === 'Imperial' ? item.dimx * scaleFactor : item.dimx * 0.3937 * scaleFactor,\n                      0,\n                      item.units === 'Imperial' ? item.dimx * scaleFactor : item.dimx * 0.3937 * scaleFactor,\n                      item.units === 'Imperial' ? (item.dimy) * scaleFactor : (item.dimy) * 0.3937 * scaleFactor],\n             strokeWidth: 2,\n             stroke: 'black',\n             shadowColor: 'red',\n             shadowBlur: 10,\n             shadowEnabled: false,\n             }\"\n    />\n  \n\n\n</v-group>\n\n</template>\n\n\n\n<script>\n\n//function prObj(obj) {return JSON.stringify(obj, undefined, 2)}\n\nexport default {\n    props: {\n        item: Object,\n        index: Number,\n        truck: Object,\n        scaleFactor: Number,\n        lowestYBound: Number,\n    },\n    mounted() {\n        //console.log(\"Pallet component mounted\"); //tmpdbg\n        \n        var closeIcon = new Image();\n        closeIcon.src = 'close.jpg';\n        closeIcon.onload = () => {\n            // set image only when it is loaded\n            this.closeIcon = closeIcon;\n        };\n        var rotateIcon = new Image();\n        rotateIcon.src = 'rotate.jpg';\n        rotateIcon.onload = () => {\n            // set image only when it is loaded\n            this.rotateIcon = rotateIcon;\n        };\n        // set y value of pallet as lower than all other pallets for width of back truck wall\n        // excluding the first one which is put in the top left corner of the truck\n        if (this.index == 0) {\n            this.$refs.cargoGroupRef.getNode().x(this.truck.originx + 11);\n            this.$refs.cargoGroupRef.getNode().y(this.truck.originy + 11);\n        } else {\n            this.$refs.cargoGroupRef.getNode().x(this.truck.originx + 11);\n            this.$refs.cargoGroupRef.getNode().y(this.lowestYBound);\n        }\n    },\n    data() {\n        return {\n            closeIcon: null,\n            rotateIcon: null,\n        };\n    },\n    methods: {\n        mouseoverPointer () {\n            document.body.style.cursor = 'pointer';\n        },\n        mouseoutPointer () {\n            document.body.style.cursor = 'default';\n        },\n    },\n};\n\n\n</script>\n\n<style scoped>\n\n</style>\n","import { render } from \"./PalletKonvaGroup.vue?vue&type=template&id=5561f8f6\"\nimport script from \"./PalletKonvaGroup.vue?vue&type=script&lang=js\"\nexport * from \"./PalletKonvaGroup.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","export function dprt(...rest) {\n    for (let i = 0; i < rest.length; i=i+2) {\n        console.group(rest[i] + \":\");\n        console.log(rest[i+1]);\n        console.groupEnd(rest[i] + \":\");\n    }\n}\n\n// let processImpactResult = [[{attrs: {cargoId: \"cargo-4\"}}, 600, 660, 'isWall'],\n//                        [{attrs: {cargoId: \"cargo-6\"}}, 100, 120, 'isWall'],\n//                        [{attrs: {cargoId: \"cargo-8\"}}, 150, 960, 'isNotWall'],\n//                        [{attrs: {cargoId: \"cargo-10\"}}, 550, 880, 'isWall']]\n\n// let resolvedArray = [[{attrs: {cargoId: \"cargo-4\"}}, 300, 400, 'isWall'],\n//                  [{attrs: {cargoId: \"cargo-6\"}}, 300, 400, 'isWall'],\n//                  [{attrs: {cargoId: \"cargo-10\"}}, 300, 400, 'isWall']]\n\n// mergeArrays(resolvedArray, processImpactResult);\n// console.log(resolvedArray.map(x=>`${x[0].attrs.cargoId},${x[1]},${x[2]},${x[3]}`))\n// => ['cargo-4,600,660,isWall', 'cargo-6,100,120,isWall', 'cargo-8,150,960,isNotWall', 'cargo-10,550,880,isWall']\n\n// destructively merges processImpactResult with resolvedArray\nexport function mergeArrays(resolvedArray, processImpactResult) {\n    let saveIndex = 0\n    for (let index = 0; index<processImpactResult.length; index++) {\n        let foundIndex = resolvedArray.findIndex(x=>(x[0].attrs.cargoId === \n                                                     processImpactResult[index][0].attrs.cargoId))\n        if( foundIndex >= 0) {\n            resolvedArray[foundIndex] = processImpactResult[index]\n            saveIndex = foundIndex;\n            \n        } else {\n            resolvedArray.splice(saveIndex+1, 0, processImpactResult[index])\n        }\n        \n    }\n}\n\n/* eslint-disable */ \n\n// call example: var intersection =\n// haveIntersection([x, x.x(), x.y(),'isNotWall'], x.findOne('Rect').getClientRect(), targetRect, target.x(), target.y())\n// left of target deltax is -ve, above target deltay is -ve\n// collidedItem: [Group, 750, 68, 'isNotWall']\nexport function haveIntersection(collidedItem, collidedItemBareRect, targetRect, targetXPos, targetYPos) {\n    var collidedItemX = collidedItem[1]\n    var collidedItemY = collidedItem[2]\n    var intersectionResult = !(targetXPos > collidedItemX + collidedItemBareRect.width || targetXPos + targetRect.width < collidedItemX || targetYPos > collidedItemY + collidedItemBareRect.height || targetYPos + targetRect.height < collidedItemY);\n    //var intersectionResult = !(r2.x       > r1.x + r1.width || r2.x       + r2.width     < r1.x || r2.y       > r1.y + r1.height || r2.y       + r2.height     < r1.y);\n    // to find the delta the lower point should have height or width added to it in the subtraction\n    // Kept here for use in TESTING_PixelPushing for how to compute intRes.transform.y:\n    // these computed values give the wrong sign for small cargo which are entirely overlapped resulting in eg. two top borders being highlighted when target is\n    // in between them :\n    // var deltax = collidedItemX < targetXPos ? targetXPos - (collidedItemX + collidedItemBareRect.width + 1)  : (targetXPos + targetRect.width + 1) - collidedItemX;\n    // var deltay = collidedItemY < targetYPos ? targetYPos - (collidedItemY + collidedItemBareRect.height + 1) : (targetYPos + targetRect.height + 1) - collidedItemY;\n\n    // target and collidedItem centerpoints\n    var targetCenterX = targetXPos + targetRect.width/2\n    var targetCenterY = targetYPos + targetRect.height/2;    \n    var collidedItemCenterX = collidedItemX + collidedItemBareRect.width/2\n    var collidedItemCenterY = collidedItemY + collidedItemBareRect.height/2\n    var centerDeltaX = collidedItemCenterX - targetCenterX; // -ve: collided is right of target, +ve: collided is left of target\n    var centerDeltaY = collidedItemCenterY - targetCenterY; // -ve: collided is below target, +ve: collided is above target\n\n    // only transform along largest axis of centerpoint distance\n    // if Math.abs(centerDeltaX) == Math.abs(centerDeltaY) then both transformx == transformy == 0 and\n    // the whichever the last highlighted border was, will remain highlighted.\n    var transformx = Math.abs(centerDeltaX) > Math.abs(centerDeltaY) ? centerDeltaX : 0\n    var transformy = Math.abs(centerDeltaX) <= Math.abs(centerDeltaY) ? centerDeltaY : 0\n\n    var intersectionObj = { intersectionResult: intersectionResult, transform: {x: transformx, y: transformy } };\n    return intersectionObj;\n}\n\n/* eslint-enable */\n\n\n//DELETE THIS IT WAS A MISTAKE USED IN OLD PROCESSIMPACT's OLD DEDUPESTACKEDCARGO\n//axisOverlap is required because the axis opposite of haveIntersection transform direction is zeroed out\nexport function axisOverlap(collidedItem, collidedItemRect, target, targetRect) {\n    // collidedItem Coordinates\n    var rect1 = {left: collidedItem.x(),\n                 right: collidedItem.x() + collidedItemRect.width,\n                 top: collidedItem.y(),\n                 bottom: collidedItem.y() + collidedItemRect.height}\n    // target Coordinates\n    var rect2 = {left: target.x(),\n                 right: target.x() + targetRect.width,\n                 top: target.y(),\n                 bottom: target.y() + targetRect.height}\n    \n    var x_overlap = Math.max(0, Math.min(rect1.right, rect2.right) - Math.max(rect1.left, rect2.left));\n    var y_overlap = Math.max(0, Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top, rect2.top));\n    return [x_overlap, y_overlap]\n}\n\n\n\n\n// targetXPos and targetYPos are used to evaluate collision with prospective new coordinates for cargo being bumped\n// otherwise cargo will only process wall collision if the old stale coordinates of target are intersecting a wall\n// processWallCollisions returns new X/Y coordinates for target, and the primary wall where most of the collision occured\n// determined by the overlap area. The primary wall is used to determine the direction in which any collided cargo will move.\n//nb: both target and layerChildren must have the backing rectangle removed before passed as arguments, because I did not have time to fix this\nexport function processWallCollisions(target, targetXPos, targetYPos, layerChildren) {\n    \n    // check collision\n    // -1 is used here because the inner rectangle is one pixel too small likely due to strokeWidth ignored\n    // haveIntersection adds 1 pixel when calculating deltax and deltay, but not during intersection checks,\n    // because it checks for cargo-cargo intersection, not cargo-wall intersection.\n    var haveIntersection = (collidedItem, collidedItemBareRect, targetRect, targetXPos, targetYPos) => \n                        !(targetXPos > collidedItem.x() + collidedItemBareRect.width \n                        || targetXPos + targetRect.width - 1< collidedItem.x() \n                        || targetYPos > collidedItem.y() + collidedItemBareRect.height \n                        || targetYPos + targetRect.height - 1< collidedItem.y());\n    \n    // konva group properties: el.attrs.cargoId, el.id(), el.y()\n    // var layerChildren = this.$refs.layer.getNode().getLayer().children;\n    var targetRect = target.findOne('Rect').getClientRect();\n    \n    var leftWall = layerChildren.find(el=>(el.attrs.truckId === 'leftWall'))\n    var backWall = layerChildren.find(el=>(el.attrs.truckId === 'backWall'))\n    var rightWall = layerChildren.find(el=>(el.attrs.truckId === 'rightWall'))\n    \n    var wall = 'isNotWall' // isWall or isNotWall\n    var wallLocation = 'isNotWall' // 'isNotWall' xor 'rightWall' xor 'leftWall' xor 'backWall'\n    \n    // Overlap Area Processing -------------------------------------------------------\n    \n    // if ?Wall is undefined in the layerChildren array passed in then set it to false for further processing below\n    var backWallCoords = backWall ? {\n        left: backWall.x?.(),\n        right: backWall.x?.() + backWall.width?.(),\n        top: backWall.y?.(),\n        bottom: backWall.y?.() + backWall.height?.(),\n    } : false\n    \n    var leftWallCoords = leftWall ? {\n        left: leftWall.x?.(),\n        right: leftWall.x?.() + leftWall.width?.(),\n        top: leftWall.y?.(),\n        bottom: leftWall.y?.() + leftWall.height?.(),\n    } : false\n    \n    var rightWallCoords = rightWall ? {\n        left: rightWall.x?.(),\n        right: rightWall.x?.() + rightWall.width?.(),\n        top: rightWall.y?.(),\n        bottom: rightWall.y?.() + rightWall.height?.(),\n    } : false\n    \n    var targetRectCoords = { left: targetXPos,\n                             right: targetXPos + targetRect.width,\n                             top: targetYPos,\n                             bottom: targetYPos + targetRect.height, }\n    \n    function overlapArea(rect1, rect2) {\n        var x_overlap = Math.max(0, Math.min(rect1.right, rect2.right) - Math.max(rect1.left, rect2.left));\n        var y_overlap = Math.max(0, Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top, rect2.top));\n        return x_overlap * y_overlap;\n    }\n    // if ?WallCoords eval to false from above, then 0 them out so they cannot be maximum\n    var overlapAreaArray = [backWallCoords ? overlapArea(backWallCoords, targetRectCoords) : 0,\n                            leftWallCoords ? overlapArea(leftWallCoords, targetRectCoords) : 0,\n                            rightWallCoords ? overlapArea(rightWallCoords, targetRectCoords) : 0]\n    \n    if(Math.max(...overlapAreaArray) == 0) {\n        wallLocation = 'isNotWall';\n    } else {\n        switch(overlapAreaArray.findIndex(x=>x==Math.max(...overlapAreaArray))) {\n        case 0:\n            wallLocation = 'backWall';\n            break;\n        case 1:\n            wallLocation = 'leftWall';\n            break;\n        case 2:\n            wallLocation = 'rightWall';\n            break;\n        default:\n            wallLocation = 'isNotWall';\n        }}\n    \n    // Collision Processing ----------------------------------------------------------------------\n    \n    \n    \n    // (collidedItem, collidedItemBareRect, targetRect, targetXPos, targetYPos)\n    var intersectLeftWallCargo = leftWall ? haveIntersection(leftWall, leftWall.getClientRect(), targetRect, targetXPos, targetYPos) : false\n    if (intersectLeftWallCargo) {\n        targetXPos = leftWall.x?.() + leftWall.width?.() + 1;\n        wall  = 'isWall';\n    }\n    \n    // (collidedItem, collidedItemBareRect, targetRect, targetXPos, targetYPos)\n    var intersectRightWallCargo = rightWall ? haveIntersection(rightWall, rightWall.getClientRect(), targetRect, targetXPos, targetYPos) : false\n    if (intersectRightWallCargo) {\n        targetXPos = rightWall.x?.() - targetRect.width\n        wall = 'isWall';\n    }\n    \n    // (collidedItem, collidedItemBareRect, targetRect, targetXPos, targetYPos)\n    var intersectBackWallCargo = backWall ? haveIntersection(backWall, backWall.getClientRect(), targetRect, targetXPos, targetYPos) : false\n    if (intersectBackWallCargo) {\n        targetYPos = backWall.y?.() + backWall.height?.() + 1;\n        wall  = 'isWall';\n    }\n    \n    \n    \n    //return [target, targetXPos, targetYPos, wall]\n    return [[target, targetXPos, targetYPos, wall], wallLocation]\n    \n    \n}\n\nexport function processImpact_debug_backup(target, targetXPos, targetYPos, wallStatus, unresolvedArray, stackName, layerChildren) {\n    // target: dragged object,\n    var targetRect = target.findOne('Rect').getClientRect();\n    // targetRect: target.findOne('Rect').getClientRect();\n    // targetXPos: the proposed position of target\n    // targetYPos: the proposed position of target\n    // unresolvedArray: layerChildren removing walls and removing target\n    stackName = stackName + \" \" + \"stackname-\" + Math.floor(Math.random() * 991 + 10);\n    //console.log(`{${stackName} processImpact called with args: target: ${target.attrs.cargoId}, targetXPos: ${targetXPos}, targetYPos: ${targetYPos}, unresolvedArray: ${JSON.stringify(unresolvedArray.map(x=>x[0].attrs.cargoId))}`); //tmpdbg\n    \n    // Check if target collides with a wall\n    // [return [target, targetXPos, targetYPos, wall]]\n    // var wallCollision = [processWallCollisions(target, targetXPos, targetYPos)];\n    var processWallCollisionsResult = processWallCollisions(target, targetXPos, targetYPos, layerChildren);\n    var wallCollision = [processWallCollisionsResult[0]]; // must be wrapped in an array for concatenation \n    var wallLocation = processWallCollisionsResult[1];\n    // Clobber local targetXPos and targetYPos if wall collision has occurred,\n    // if no collision has occurred then use the new targetX/YPos arguments that have been passed in instead\n    if (wallCollision[0][3] === 'isWall') {\n        targetXPos = wallCollision[0][1];\n        targetYPos = wallCollision[0][2];\n        //console.log(` ${stackName} due to a wall collision targetXPos and targetYPos are being clobbered: target.attrs.cargoId: ${target.attrs.cargoId} targetXPos: ${targetXPos} targetYPos: ${targetYPos}`); //tmpdbg\n    }\n    \n    var inheritCollision = (wallCollision[0][3] === 'isWall') || (wallStatus === 'isWall')  ? 'isWall' : 'isNotWall'\n    \n    //resolvedArray is the first wave of collision with target\n    // each resolvedArray item has: resolvedArray[0] = collidedItem cargo konva object\n    // resolvedArray[0],[1] = assign first wave collisions new X/Y coordinates\n    // resolvedArray[2] = 'isWall' if target has collided with wall wallCollision[0][3]==='isWall' above,\n    //                     or wallStatus arg = 'isWall' chained forward in processImpact arg due to a target \n    //                     colliding with a wall in the past of the chain\n    var resolvedArray = unresolvedArray.map( function(collidedItem) {\n        var collidedItemX = collidedItem[1]\n        var collidedItemY = collidedItem[2]\n        var bareRect = collidedItem[0].findOne('Rect').getClientRect();\n        var preCollisionIntersection = haveIntersection(collidedItem, bareRect, targetRect, target.x(), target.y())                \n        // var intersectionObj = { intersectionResult: intersectionResult, transform: {x: transformx, y: transformy } };\n        var intersection = haveIntersection(collidedItem, bareRect, targetRect, targetXPos, targetYPos)                \n        if (intersection.intersectionResult) {\n            // If target has collided with wall, push collidedItem in opposite direction of wall\n            // else push in direction of axis with smallest overlap\n            // The purpose of preCollisionIntersection.transform.x == 0 is to prevent all objects in the \n            // unresolvedArray to be pushed downwards just because the target intersected the wallLocation = 'backWall'\n            switch(true) {\n            case (wallLocation === 'backWall'  && preCollisionIntersection.transform.x == 0):\n                return [collidedItem[0], collidedItemX, targetYPos+targetRect.height+1, inheritCollision];                        \n            case (wallLocation === 'rightWall' && preCollisionIntersection.transform.y == 0):\n                return [collidedItem[0], targetXPos-bareRect.width-1, collidedItemY, inheritCollision];\n            case (wallLocation === 'leftWall' && preCollisionIntersection.transform.y == 0):\n                return [collidedItem[0], targetXPos+targetRect.width+1, collidedItemY, inheritCollision];                        \n            default: //(wallLocation === 'isNotWall')\n                if (Math.abs(intersection.transform.x) < Math.abs(intersection.transform.y)) { // in y direction\n                    if(intersection.transform.y < 0) { // above\n                        //collidedItem above y transform is -ve\n                        return [collidedItem[0], collidedItemX, targetYPos-bareRect.height-1, inheritCollision]\n                    } else { // below (0 or more)\n                        //collidedItem below y transform is +ve\n                        return [collidedItem[0], collidedItemX, targetYPos+targetRect.height+1, inheritCollision]\n                    }\n                    \n                } else { // in x direction\n                    if(intersection.transform.x < 0) { // to the left\n                        //collidedItem left x transform is -ve\n                        return [collidedItem[0], targetXPos-bareRect.width-1, collidedItemY, inheritCollision] \n                    } else { // to the right 0 or more\n                        //collidedItem right x transform is +ve\n                        return [collidedItem[0], targetXPos+targetRect.width+1, collidedItemY, inheritCollision] \n                    }\n                }\n            }\n        }\n    }.bind(this))\n\n    \n    // if there are no collisions if (intersection.intersectionResult) {...}\n    // will return undefined in the final map result; remove this undefined:\n    resolvedArray = resolvedArray.filter(function(el) {return el !== undefined});\n    // console.log(` ${stackName} First collision wave completed with target: ` + JSON.stringify(target.attrs.cargoId) +\n    //             \" unresolvedArray: \" + JSON.stringify(unresolvedArray.map(x=>x[0].attrs.cargoId)) +\n    //             \" resolvedArray: \" + JSON.stringify(resolvedArray.map(x=>[x[0].attrs.cargoId, x[1], x[2],x[3]]))); //tmpdbg\n\n    \n    // accumArray is chain reaction collisions beyond the first wave\n    var accumArray = []\n    resolvedArray.forEach( function(item) {\n        var newTarget = item[0];\n        var newTargetXPos = item[1];\n        var newTargetYPos = item[2];\n        var newUnresolvedArray = unresolvedArray.filter(function(el) {return el[0] !== newTarget});\n\n        // console.log(` ${stackName} START building accumArray: resolvedArray.forEach calling processImpact ` +\n        //             \" newTarget: \" + JSON.stringify(newTarget.attrs.cargoId) +\n        //             \" newUnresolvedArray: \" + JSON.stringify(newUnresolvedArray.map(x=>x[0].attrs.cargoId))); //tmpdbg\n        \n        var newResolvedArray = processImpact(newTarget, newTargetXPos, newTargetYPos, inheritCollision, newUnresolvedArray, stackName, layerChildren);\n        accumArray = accumArray.concat(newResolvedArray);\n\n        // console.log(` ${stackName} END building accumArray: resolvedArray.forEach returned from processImpact ` +\n        //             \" newResolvedArray: \" + JSON.stringify(newResolvedArray.map(x=>[x[0].attrs.cargoId, x[1], x[2],x[3]])) +\n        //             \" accumArray = accumArray.concat(newResolvedArray): \" + JSON.stringify(accumArray.map(x=>[x[0].attrs.cargoId, x[1], x[2],x[3]]))); //tmpdbg\n\n        \n    }.bind(this))\n    \n    //reprocess accumArray values here\n    \n    //save all walls returned from processImpact calls\n    let blowbackTargetArray = accumArray.filter(x=>x[3]==='isWall')\n    \n    \n    // merge target back to unresolvedArray\n    let checkIndex = unresolvedArray.findIndex(x=>(x[0].attrs.cargoId === target.attrs.cargoId))\n    \n    let blowbackUnresolvedArray = [];\n    if(checkIndex >= 0) {\n        blowbackUnresolvedArray = unresolvedArray.slice();\n        blowbackUnresolvedArray[checkIndex] = [target, targetXPos, targetYPos, wallStatus];\n    } else {\n        blowbackUnresolvedArray = unresolvedArray.concat([[target, targetXPos, targetYPos, wallStatus]])\n    }\n    \n    let blowbackResult = []\n    //call processImpact on every wall blowback cargo as target, with current target added back to unresolvedArray\n    blowbackTargetArray.forEach(function(blowbackCargoTarget){\n        blowbackUnresolvedArray = blowbackUnresolvedArray.filter(x=>(!(x[0].attrs.cargoId === blowbackCargoTarget[0].attrs.cargoId)))\n        //console.log(` ${stackName} START building blowbackResult: blowbackTargetArray.forEach calling processImpact` + \" blowbackTargetArray: \" + JSON.stringify(blowbackTargetArray.map(x=>[x[0].attrs.cargoId, x[1], x[2],x[3]])) + \" blowbackUnresolvedArray: \" + JSON.stringify(blowbackUnresolvedArray.map(x=>x[0].attrs.cargoId))); //tmpdbg\n        blowbackResult = blowbackResult.concat(processImpact(blowbackCargoTarget[0], blowbackCargoTarget[1], blowbackCargoTarget[2], 'isWall', blowbackUnresolvedArray, stackName, layerChildren));\n    }.bind(this))\n    \n    //console.log(` ${stackName} END building blowbackResult: ` + JSON.stringify(blowbackResult.map(x=>[x[0].attrs.cargoId, x[1], x[2],x[3]]))); //tmpdbg\n    \n    mergeArrays(accumArray, blowbackResult);\n    \n    // wallCollision == [return [target, targetXPos, targetYPos, wall]]\n    if (wallCollision[0][3] === 'isWall') {\n        //resolvedArray = wallCollision.concat(resolvedArray, accumArray);\n        mergeArrays(resolvedArray, accumArray);\n        var temp = wallCollision // am not clobbering wallCollision for no reason\n        mergeArrays(temp, resolvedArray);\n        // basically I did not realize if a cargo has a wall collision, it may be hit by another cargo in the same chain ,\n        // reaction eg. displacing a cargo in the top right corner which then ricocheting back off the right wall\n        // so I replaced the concatenation here with merge above.\n        //resolvedArray = wallCollision.concat(resolvedArray); \n        resolvedArray = temp;\n    } else {\n        //resolvedArray = resolvedArray.concat(accumArray);\n        mergeArrays(resolvedArray, accumArray);\n    }\n    //console.log(` ${stackName} returning resolvedArray:` + JSON.stringify(resolvedArray.map(x=>[x[0].attrs.cargoId, x[1], x[2],x[3]])) + \"}\"); //tmpdbg\n    return resolvedArray;\n    \n}\n\n//nb: both target and layerChildren must have the backing rectangle removed before passed as arguments, because I did not have time to fix this\nexport function processImpact(target, targetXPos, targetYPos, wallStatus, unresolvedArray, stackName, layerChildren) {\n    // target: dragged object,\n    var targetRect = target.findOne('Rect').getClientRect();\n    // targetRect: target.findOne('Rect').getClientRect();\n    // targetXPos: the proposed position of target\n    // targetYPos: the proposed position of target\n    // unresolvedArray: layerChildren removing walls and removing target\n    stackName = stackName + \" \" + \"stackname-\" + Math.floor(Math.random() * 991 + 10);\n    //console.log(`{${stackName} processImpact called with args: target: ${target.attrs.cargoId}, targetXPos: ${targetXPos}, targetYPos: ${targetYPos}, unresolvedArray: ${JSON.stringify(unresolvedArray.map(x=>x[0].attrs.cargoId))}`);\n    \n    // Check if target collides with a wall\n    // [return [target, targetXPos, targetYPos, wall]]\n    // var wallCollision = [processWallCollisions(target, targetXPos, targetYPos)];\n    var processWallCollisionsResult = processWallCollisions(target, targetXPos, targetYPos, layerChildren);\n    var wallCollision = [processWallCollisionsResult[0]]; // must be wrapped in an array for concatenation \n    var wallLocation = processWallCollisionsResult[1];\n    // Clobber local targetXPos and targetYPos if wall collision has occurred,\n    // if no collision has occurred then use the new targetX/YPos arguments that have been passed in instead\n    if (wallCollision[0][3] === 'isWall') {\n        targetXPos = wallCollision[0][1];\n        targetYPos = wallCollision[0][2];\n        //console.log(` ${stackName} due to a wall collision targetXPos and targetYPos are being clobbered: target.attrs.cargoId: ${target.attrs.cargoId} targetXPos: ${targetXPos} targetYPos: ${targetYPos}`);\n    }\n    \n    var inheritCollision = (wallCollision[0][3] === 'isWall') || (wallStatus === 'isWall')  ? 'isWall' : 'isNotWall'\n    \n    //resolvedArray is the first wave of collision with target\n    // each resolvedArray item has: resolvedArray[0] = collidedItem cargo konva object\n    // resolvedArray[0],[1] = assign first wave collisions new X/Y coordinates\n    // resolvedArray[2] = 'isWall' if target has collided with wall wallCollision[0][3]==='isWall' above,\n    //                     or wallStatus arg = 'isWall' chained forward in processImpact arg due to a target \n    //                     colliding with a wall in the past of the chain\n    var resolvedArray = unresolvedArray.map( function(collidedItem) {\n        var collidedItemX = collidedItem[1]\n        var collidedItemY = collidedItem[2]\n        var bareRect = collidedItem[0].findOne('Rect').getClientRect();\n        var preCollisionIntersection = haveIntersection(collidedItem, bareRect, targetRect, target.x(), target.y())                \n        // var intersectionObj = { intersectionResult: intersectionResult, transform: {x: transformx, y: transformy } };\n        var intersection = haveIntersection(collidedItem, bareRect, targetRect, targetXPos, targetYPos)                \n        if (intersection.intersectionResult) {\n            // If target has collided with wall, push collidedItem in opposite direction of wall\n            // else push in direction of axis with smallest overlap\n            // The purpose of preCollisionIntersection.transform.x == 0 is to prevent all objects in the \n            // unresolvedArray to be pushed downwards just because the target intersected the wallLocation = 'backWall'\n            switch(true) {\n            case (wallLocation === 'backWall'  && preCollisionIntersection.transform.x == 0):\n                return [collidedItem[0], collidedItemX, targetYPos+targetRect.height+1, inheritCollision];                        \n            case (wallLocation === 'rightWall' && preCollisionIntersection.transform.y == 0):\n                return [collidedItem[0], targetXPos-bareRect.width-1, collidedItemY, inheritCollision];\n            case (wallLocation === 'leftWall' && preCollisionIntersection.transform.y == 0):\n                return [collidedItem[0], targetXPos+targetRect.width+1, collidedItemY, inheritCollision];                        \n            default: //(wallLocation === 'isNotWall')\n                if (Math.abs(intersection.transform.x) < Math.abs(intersection.transform.y)) { // in y direction\n                    if(intersection.transform.y < 0) { // above\n                        //collidedItem above y transform is -ve\n                        return [collidedItem[0], collidedItemX, targetYPos-bareRect.height-1, inheritCollision]\n                    } else { // below (0 or more)\n                        //collidedItem below y transform is +ve\n                        return [collidedItem[0], collidedItemX, targetYPos+targetRect.height+1, inheritCollision]\n                    }\n                    \n                } else { // in x direction\n                    if(intersection.transform.x < 0) { // to the left\n                        //collidedItem left x transform is -ve\n                        return [collidedItem[0], targetXPos-bareRect.width-1, collidedItemY, inheritCollision] \n                    } else { // to the right 0 or more\n                        //collidedItem right x transform is +ve\n                        return [collidedItem[0], targetXPos+targetRect.width+1, collidedItemY, inheritCollision] \n                    }\n                }\n            }\n        }\n    }.bind(this))\n\n    \n    // if there are no collisions if (intersection.intersectionResult) {...}\n    // will return undefined in the final map result; remove this undefined:\n    resolvedArray = resolvedArray.filter(function(el) {return el !== undefined});\n    // console.log(` ${stackName} First collision wave completed with target: ` + JSON.stringify(target.attrs.cargoId) +\n    //             \" unresolvedArray: \" + JSON.stringify(unresolvedArray.map(x=>x[0].attrs.cargoId)) +\n    //             \" resolvedArray: \" + JSON.stringify(resolvedArray.map(x=>[x[0].attrs.cargoId, x[1], x[2],x[3]])));\n\n    \n    // accumArray is chain reaction collisions beyond the first wave\n    var accumArray = []\n    resolvedArray.forEach( function(item) {\n        var newTarget = item[0];\n        var newTargetXPos = item[1];\n        var newTargetYPos = item[2];\n        var newUnresolvedArray = unresolvedArray.filter(function(el) {return el[0] !== newTarget});\n\n        // console.log(` ${stackName} START building accumArray: resolvedArray.forEach calling processImpact ` +\n        //             \" newTarget: \" + JSON.stringify(newTarget.attrs.cargoId) +\n        //             \" newUnresolvedArray: \" + JSON.stringify(newUnresolvedArray.map(x=>x[0].attrs.cargoId)));\n        \n        var newResolvedArray = processImpact(newTarget, newTargetXPos, newTargetYPos, inheritCollision, newUnresolvedArray, stackName, layerChildren);\n        accumArray = accumArray.concat(newResolvedArray);\n\n        // console.log(` ${stackName} END building accumArray: resolvedArray.forEach returned from processImpact ` +\n        //             \" newResolvedArray: \" + JSON.stringify(newResolvedArray.map(x=>[x[0].attrs.cargoId, x[1], x[2],x[3]])) +\n        //             \" accumArray = accumArray.concat(newResolvedArray): \" + JSON.stringify(accumArray.map(x=>[x[0].attrs.cargoId, x[1], x[2],x[3]])));\n\n        \n    }.bind(this))\n    \n    //reprocess accumArray values here\n    \n    //save all walls returned from processImpact calls\n    let blowbackTargetArray = accumArray.filter(x=>x[3]==='isWall')\n    \n    \n    // merge target back to unresolvedArray\n    let checkIndex = unresolvedArray.findIndex(x=>(x[0].attrs.cargoId === target.attrs.cargoId))\n    \n    let blowbackUnresolvedArray = [];\n    if(checkIndex >= 0) {\n        blowbackUnresolvedArray = unresolvedArray.slice();\n        blowbackUnresolvedArray[checkIndex] = [target, targetXPos, targetYPos, wallStatus];\n    } else {\n        blowbackUnresolvedArray = unresolvedArray.concat([[target, targetXPos, targetYPos, wallStatus]])\n    }\n    \n    let blowbackResult = []\n    //call processImpact on every wall blowback cargo as target, with current target added back to unresolvedArray\n    blowbackTargetArray.forEach(function(blowbackCargoTarget){\n        blowbackUnresolvedArray = blowbackUnresolvedArray.filter(x=>(!(x[0].attrs.cargoId === blowbackCargoTarget[0].attrs.cargoId)))\n        // console.log(` ${stackName} START building blowbackResult: blowbackTargetArray.forEach calling processImpact` + \" blowbackTargetArray: \" + JSON.stringify(blowbackTargetArray.map(x=>[x[0].attrs.cargoId, x[1], x[2],x[3]])) + \" blowbackUnresolvedArray: \" + JSON.stringify(blowbackUnresolvedArray.map(x=>x[0].attrs.cargoId)));\n        blowbackResult = blowbackResult.concat(processImpact(blowbackCargoTarget[0], blowbackCargoTarget[1], blowbackCargoTarget[2], 'isWall', blowbackUnresolvedArray, stackName, layerChildren));\n    }.bind(this))\n    \n    // console.log(` ${stackName} END building blowbackResult: ` + JSON.stringify(blowbackResult.map(x=>[x[0].attrs.cargoId, x[1], x[2],x[3]])));\n    \n    mergeArrays(accumArray, blowbackResult);\n    \n    // wallCollision == [return [target, targetXPos, targetYPos, wall]]\n    if (wallCollision[0][3] === 'isWall') {\n        //resolvedArray = wallCollision.concat(resolvedArray, accumArray);\n        mergeArrays(resolvedArray, accumArray);\n        var temp = wallCollision // am not clobbering wallCollision for no reason\n        mergeArrays(temp, resolvedArray);\n        // basically I did not realize if a cargo has a wall collision, it may be hit by another cargo in the same chain ,\n        // reaction eg. displacing a cargo in the top right corner which then ricocheting back off the right wall\n        // so I replaced the concatenation here with merge above.\n        //resolvedArray = wallCollision.concat(resolvedArray); \n        resolvedArray = temp;\n    } else {\n        //resolvedArray = resolvedArray.concat(accumArray);\n        mergeArrays(resolvedArray, accumArray);\n    }\n    // console.log(` ${stackName} returning resolvedArray:` + JSON.stringify(resolvedArray.map(x=>[x[0].attrs.cargoId, x[1], x[2],x[3]])) + \"}\");\n    return resolvedArray;\n    \n}\n\n/* eslint-disable */ \n// call example:\n// var layerChildren = this.$refs.layer.getNode().getLayer().children;\n// var target = layerChildren.find(x=>x.attrs.cargoId === 'cargo-1');\n// collision.findOverlaps(target, target.x(), target.y(), layerChildren);\n// returns: [KonvaObject, {intersectionResult: true, transform: {x: 25, y: 36}}]\nexport function findOverlaps(target, targetXPos, targetYPos, layerChildren){\n    //console.log(\"findOverlaps called:\");\n    var targetRect = target.findOne('Rect').getClientRect();\n\n    //find all intersections with target    \n    let layerChildrenNoTarget = layerChildren.filter(el => !(el.attrs.cargoId === target.attrs.cargoId));\n    let cargoArray = layerChildrenNoTarget.filter(el => !(el.id() === 'truckWall'))\n\n    let targetIntersectionArray = cargoArray.map(x => [x, haveIntersection([x, x.x(), x.y(), 'isNotWall'], x.findOne('Rect').getClientRect(),\n        targetRect, targetXPos, targetYPos)]).filter(x => (x[1].intersectionResult == true));\n\n    // DEBUG:\n    // console.log(targetIntersectionArray)\n    // if (targetIntersectionArray.length > 0) {\n    //     console.log(\"findOverlaps: some intersection is occuring\")\n    //     dprt(\"findOverlaps: return value: \", targetIntersectionArray.map(x=>x[0]));\n    //     console.table(targetIntersectionArray.map(x=>[x[0].attrs.cargoId, x[1].intersectionResult, x[1].transform.x, x[1].transform.y]))\n    // } else {\n    //     console.log(\"findOverlaps: no intersection is occuring\")\n    // }\n    return  targetIntersectionArray.map(x=>x[0]);\n}\n\n//Finds all overlapping cargo and sorts them in orthogonal directions of proximity to target\nexport function dedupeStackedCargo(target, layerChildren){\n    // target, targetRect, unresolvedArray\n    var targetId = target.attrs.cargoId;    \n    var targetRect = target.findOne('Rect').getClientRect();\n    // cargoGroup elements without targetId\n    var cargoGroupArray = layerChildren.filter(el => (el.id() === 'cargoGroup' && !(el.attrs.cargoId === targetId)))\n    \n    // var resolvedArrayIntersection =\n    //     resolvedArray.map(x=>[x[0], haveIntersection([x[0], x[0].x(), x[0].y(), 'isNotWall'],\n    //                                                  x[0].findOne('Rect').getClientRect(),\n    //                                                  targetRect, target.x(), target.y())]);\n\n    var unresolvedArrayIntersection =\n        cargoGroupArray.map(x=>[x, haveIntersection([x, x.x(), x.y(), 'isNotWall'], x.findOne('Rect').getClientRect(),\n                                                    targetRect, target.x(), target.y())]);\n    // => [[Kobj, {intersectionResult: true, transform: {x: 0, y: 88}}], [Kobj, {intersectionResult: true, transform: {x: 0, y: 6}}]]\n    \n    // all overlapping cargo below y>=0, right x>0, left x<0, and above y<=0 the target\n    var belowArray = unresolvedArrayIntersection.filter(x=>(x[1].intersectionResult == true && x[1].transform.y>0));\n    var rightArray = unresolvedArrayIntersection.filter(x=>(x[1].intersectionResult == true && x[1].transform.x>0));\n    var leftArray = unresolvedArrayIntersection.filter(x=>(x[1].intersectionResult == true && x[1].transform.x<0));\n    var aboveArray = unresolvedArrayIntersection.filter(x=>(x[1].intersectionResult == true && x[1].transform.y<0));\n    // => [[Kobj, {intersectionResult: true, transform: {x: 0, y: 88}}], [Kobj, {intersectionResult: true, transform: {x: 0, y: 6}}]]    \n\n    // if transform.y > 0 then the cargo is below the target, remove all cargo except the one with the lowest \n    // precollision y coordinate:\n    // sort by y coordinate increasing and remove the smallest element, discard y coordinates from the array\n    var dedupeStackedCargoBelow = belowArray.map(x=>[x[0],x[0].y()]).sort((a,b)=>a[1] > b[1] ? 1: -1);\n    var dedupeStackedCargoRight = rightArray.map(x=>[x[0],x[0].x()]).sort((a,b)=>a[1] > b[1] ? 1: -1);\n    var dedupeStackedCargoLeft = leftArray.map(x=>[x[0],x[0].x()]).sort((a,b)=>a[1] < b[1] ? 1: -1);\n    var dedupeStackedCargoAbove = aboveArray.map(x=>[x[0],x[0].y()]).sort((a,b)=>a[1] < b[1] ? 1: -1);\n\n    // dprt(\"dedupeStackedCargoBelow\", dedupeStackedCargoBelow,\n    //      \"dedupeStackedCargoRight\", dedupeStackedCargoRight,\n    //      \"dedupeStackedCargoLeft\", dedupeStackedCargoLeft,\n    //      \"dedupeStackedCargoAbove\", dedupeStackedCargoAbove); //tmpdbg\n    // dprt(\"dedupeStackedCargo return value: \", {above: dedupeStackedCargoAbove, below: dedupeStackedCargoBelow, right: dedupeStackedCargoRight, left: dedupeStackedCargoLeft}) //tmpdbg\n\n    var dedupedResult = {above: dedupeStackedCargoAbove, below: dedupeStackedCargoBelow, right: dedupeStackedCargoRight, left: dedupeStackedCargoLeft}\n\n\n\n    return dedupedResult;\n\n}\n\n// update cargoGroupArray with values from piRes\n// var piRes = [[{attrs: {cargoId: 'cargo-2'}}, 2, 2, 'isNotWall'],\n//              [{attrs: {cargoId: 'cargo-3'}}, 3, 3, 'isNotWall'],\n//              [{attrs: {cargoId: 'cargo-5'}}, 5, 5, 'isNotWall'],\n//              [{attrs: {cargoId: 'cargo-99'}}, 8, 8, 'isNotWall']]\n\n// var cargoGroupArray = [[{attrs: {cargoId: 'cargo-1'}}, 111, 111, 'isNotWall'],\n//                        [{attrs: {cargoId: 'cargo-2'}}, 222, 222, 'isNotWall'],\n//                        [{attrs: {cargoId: 'cargo-3'}}, 333, 333, 'isNotWall'],\n//                        [{attrs: {cargoId: 'cargo-4'}}, 444, 444, 'isNotWall'],\n//                        [{attrs: {cargoId: 'cargo-5'}}, 555, 555, 'isNotWall']]\n\n// updateCargoGroupArray(piRes, cargoGroupArray)\n// updates cargoGroupArray coordinate values with values from piRes, where piRes is a processImpact result\n// and cargoGroupArray is to be used as the unresolved array in the next iteration of processImpact call\nfunction updateCargoGroupArray (piRes, cargoGroupArray) {\n    piRes.forEach(function(resolved) {\n        var resolvedId = resolved[0].attrs.cargoId;\n        var resolvedX = resolved[1];\n        var resolvedY = resolved[2];\n        // undefined is falsy\n        var foundCargoIndex = cargoGroupArray.findIndex(x=>x[0].attrs.cargoId === resolvedId);\n        if(foundCargoIndex >= 0) {\n            cargoGroupArray[foundCargoIndex][1] = resolvedX;\n            cargoGroupArray[foundCargoIndex][2] = resolvedY;\n            \n        }\n    })}\n\n\n// for pixel push debugging    \n// function sleep(ms) {\n//     return new Promise(resolve => setTimeout(resolve, ms));\n// }    \n\n//export async function pixelPush(layerChildren) {\n//nb: both target and layerChildren must have the backing rectangle removed before passed as arguments, because I did not have time to fix this\nexport function pixelPush(target, layerChildren, saveStartDragCoords) {\n    var targetId = target.attrs.cargoId;    \n    var targetRect = target.findOne('Rect').getClientRect();\n    var cargoGroupArray = layerChildren.filter(el => (el.id() === 'cargoGroup' && !(el.attrs.cargoId === targetId)));\n    cargoGroupArray = cargoGroupArray.map(x => [x, x.x(), x.y(), 'isNotWall'])\n\n    // dprt(\"pixelPush: target: \", target)\n    var backWall = layerChildren.find(el => (el.attrs.truckId === 'backWall'))\n    var leftWall = layerChildren.find(el => (el.attrs.truckId === 'leftWall'))\n    var rightWall = layerChildren.find(el => (el.attrs.truckId === 'rightWall'))\n    // + 1 is used to clear the wall width, and it is not necessary to clear the wall when subtracting\n    var bottomOfBackWall = backWall.y() + backWall.height() - targetRect.height;\n    var rightOfLeftWall = leftWall.x() + leftWall.width() - targetRect.width;\n    var leftOfRightWall = rightWall.x() + 1;\n\n    var resWall = processWallCollisions(target, target.x(), target.y(), layerChildren);\n    // [[Group, 797, 68, 'isNotWall'], \"rightWall\"]\n    // dprt(\"pixelPush: processWallCollision result, resWall:\", resWall, \"resWall[1]\", resWall[1])\n\n    //async function pixelPushFromBorder(startWallPushX, startWallPushY, postWallCollisionX, postWallCollisionY) {\n    function pixelPushFromBorder(startWallPushX, startWallPushY, postWallCollisionX, postWallCollisionY) {\n        // the starting position to the target cargo\n        target.x(startWallPushX);\n        target.y(startWallPushY);\n\n        //change target.Rect.height/width and testCargo1.x/y(testCargo1.x/y() +/- 1) depending on resWall[1] '?Wall' value\n        //also check border overlap by setting it to red\n\n        // reset layerChildrenRemoveWall to include all walls before a single wall is removed again\n        var layerChildrenRemoveWall = layerChildren;\n        // collidedWall is defined in the calling scope and is equal to resWall[1] // + 1 is required to clear the wall\n        for (let i = 0; i < ((collidedWall === 'backWall') ? targetRect.height + 1 : targetRect.width + 1); i++) {\n            //for (let i = 0; i < 80; i++) { // 87 ok, 88 fail ; i\n            //if (i == 89) { debugger }\n            //dprt(\"targetRect.height\", targetRect.height, \"targetRect.width\", targetRect.width) //tmpdbg\n            switch (collidedWall) {\n                case 'backWall':\n                    target.y(target.y() + 1);\n                    layerChildrenRemoveWall = layerChildren.filter(x => !(x.attrs.truckId === 'backWall'))\n                    break;\n                case 'leftWall':\n                    target.x(target.x() + 1);\n                    layerChildrenRemoveWall = layerChildren.filter(x => !(x.attrs.truckId === 'leftWall'))\n                    break;\n                case 'rightWall':\n                    target.x(target.x() - 1);\n                    layerChildrenRemoveWall = layerChildren.filter(x => !(x.attrs.truckId === 'rightWall'))\n                    break;\n                default:\n                    // 'isNotWall' unreachable from if (!(resWall[1] === 'isNotWall')) calling context \n                    break;\n            }\n\n            //processImpact(target, targetXPos, targetYPos, wallStatus, unresolvedArray, stackName, layerChildren)\n            //unresolvedArray = unresolvedArray.map(x=>[x, x.x(), x.y(), 'isNotWall']) \n            //piRes = [[Group, 797, 24, 'isNotWall']]\n            //cargoGroupArray = cargoGroupArray.map(x=>[x, x.x(), x.y(), 'isNotWall']) \n            var piRes = processImpact(target, target.x(), target.y(),\n                'isNotWall',\n                // cargoGroupArray is all non wall cargoGroup elements excluding target\n                cargoGroupArray,\n                \"\", layerChildrenRemoveWall);\n            //await sleep(100); // use requires async keyword in pixelPushFromBorder and outer function pixelPush \n            // You must update cargogrouparray with processImpact results or else collided cargo will keep\n            // using the stale konva object coordinates the cargoGroupArray.map call initializes the nested \n            // array values to at the top of this function. These array values are used in the haveIntersection \n            // call in processImpact when computing resolvedArray from unresolved array to allow lazy update\n            // of coordinates after processImpact is complete, instead of updating the konva objects directly.\n            updateCargoGroupArray(piRes, cargoGroupArray);\n            piRes.forEach(function (kgroup) {\n                var collidedItem = kgroup[0];\n                collidedItem.x(kgroup[1]);\n                collidedItem.y(kgroup[2]);\n            })\n        }\n\n        // [target.findOne(x => x.id() === 'topBorder'),\n        //     target.findOne(x => x.id() === 'bottomBorder'),\n        //     target.findOne(x => x.id() === 'rightBorder'),\n        //     target.findOne(x => x.id() === 'leftBorder')].forEach(x => x.stroke(\"red\"))\n\n    }\n\n\n    // \"Are there wall collisions?\"\n    if (!(resWall[1] === 'isNotWall')) {\n        // find the new post collision position, and pixel push the cargo from the edge of the wall to its final position going in a direction\n        // orthogonal to the collided wall\n        // pixelPush***\n        var collidedWall = resWall[1]\n        var postWallCollisionX = resWall[0][1];\n        var postWallCollisionY = resWall[0][2];\n        switch (collidedWall) {\n            case 'backWall':\n                var startWallPushX = postWallCollisionX;\n                var startWallPushY = bottomOfBackWall\n                pixelPushFromBorder(startWallPushX, startWallPushY, postWallCollisionX, postWallCollisionY);\n                break;\n\n            case 'leftWall':\n                var startWallPushX = rightOfLeftWall;\n                var startWallPushY = postWallCollisionY;\n                pixelPushFromBorder(startWallPushX, startWallPushY, postWallCollisionX, postWallCollisionY);\n                break;\n\n            case 'rightWall':\n                var startWallPushX = leftOfRightWall\n                var startWallPushY = postWallCollisionY;\n                pixelPushFromBorder(startWallPushX, startWallPushY, postWallCollisionX, postWallCollisionY);\n                break;\n\n            default:\n                // will NOT execute because of containing if condiition: !(resWall[1] === 'isNotWall')\n                break;\n        }\n\n\n\n\n        // If the final target cargo location is on top of a wall, let the target fall outside the truck on the opposite side of the wall.\n        var resWallPostColl = processWallCollisions(target, target.x(), target.y(), layerChildren)\n        // [[Group, 797, 40, 'isWall'] \"rightWall\"]\n        let layerChildrenNoTarget = layerChildren.filter(el => !(el.attrs.cargoId === target.attrs.cargoId));\n        let cargoArray = layerChildrenNoTarget.filter(el => !(el.id() === 'truckWall'))\n\n        let targetIntersectionArray = cargoArray.map(x => [x, haveIntersection([x, x.x(), x.y(), 'isNotWall'], x.findOne('Rect').getClientRect(),\n            targetRect, target.x(), target.y())]).filter(x => (x[1].intersectionResult == true));\n\n        // console.log(resWallPostColl)\n        // console.log(targetIntersectionArray)\n\n        if (!(resWallPostColl[1] === 'isNotWall') || targetIntersectionArray.length > 0) {\n            // Reposition the cargo on the other side of the wall it collided with\n            // CODE2**\n            // Note resWallPostColl contains the final objective coordinates for a wall collision\n            // target.x() and target.y() are the current coordinates of the target after pixelpushing \n            // has failed\n            var collidedWallPostColl = resWallPostColl[1]; // [[Group, 797, 40, 'isWall'] \"rightWall\"]\n            var postFailedCollX = target.x()\n            var postFailedCollY = target.y()\n\n            //dprt(\"pixelPush: resWallPostColl: \", resWallPostColl, \"postFailedCollX\", postFailedCollX, \"postFailedCollY\", postFailedCollY) //tmpdbg\n            switch (collidedWallPostColl) {\n                case 'backWall':\n                    target.y(backWall.y() - targetRect.height)\n                    break;\n\n                case 'leftWall':\n                    target.x(leftWall.x() - targetRect.width)\n                    break;\n\n                case 'rightWall':\n                    // var failedX = right of rightwall\n                    target.x(rightWall.x() + rightWall.width() + 1)\n                    break;\n\n                default:\n                    // will NOT execute because of containing if condiition: !(resWall[1] === 'isNotWall')\n                    break;\n            }\n            //console.log(\"CODE2: some intersection is still occuring\")\n        } else {\n            //console.log(\"CODE2: no intersection is occuring\")\n        }\n\n        // if there are no wall collisions, check for cargo collisions\n    } else {\n\n        //console.log(\"There are no wall collisions\") //tmpdbg\n\n\n        // do not check wall collisions because wall intersections are impossible in the else condition and are \n        // handled in the above if condition\n\n        // dedupeStackedCargo finds and seperates all collided cargo into above, below, left and right\n        var dedupeCargo = dedupeStackedCargo(target, layerChildren)\n        // dedupeCargo is: {above: [[Group, 120], [Group, 110]], below: [[Group, 230]], left: [], right: []}\n\n        var totalDedupedElements = dedupeCargo.above.length + dedupeCargo.below.length + dedupeCargo.left.length + dedupeCargo.right.length;\n\n        if (totalDedupedElements > 0) {\n\n            //dprt(\"CODE3: no wall collisions but cargo collisions were found: sum of directions in dedupeCargo: \", \n            //    (dedupeCargo.above.length + dedupeCargo.below.length + dedupeCargo.left.length + dedupeCargo.right.length)); //tmpdbg\n            // At the drop location run dedupeStackedCargo and for each of the 4 transform directions remove all other overlapping cargo and walls\n            // and pixelpush in that transform direction for distance of the overlap.\n            // CODE3*****\n\n            // var dedupeCargo = dedupeStackedCargo(target, layerChildren)\n            // {above: [[Group, 120], [Group, 110]], below: [[Group, 230]], left: [[Group, 325]], right: [[Group, 475]]}\n\n            if (dedupeCargo.above.length > 0) {\n                var aboveCargo = dedupeCargo.above[0][0]\n                var aboveCargoY = dedupeCargo.above[0][1]\n                var aboveCargoRect = aboveCargo.findOne('Rect').getClientRect();\n                var startingLocationAbove = aboveCargoY + aboveCargoRect.height + 1;\n                var remWallObstructionAbove = processWallCollisions(target, target.x(), startingLocationAbove, layerChildren)[1];\n                var layerChildrenRemWallAbove = layerChildren.filter(x => !(x.attrs.truckId === remWallObstructionAbove));\n\n                // obstructionsRight is: ['cargo-3', 'cargo-4', 'cargo-5']\n                // cargoGroupArray is defined above as:\n                // var cargoGroupArray = layerChildren.filter(el => (el.id() === 'cargoGroup' && !(el.attrs.cargoId === targetId)));\n                // cargoGroupArray = cargoGroupArray.map(x => [x, x.x(), x.y(), 'isNotWall'])\n                // filter all obstructions out of cargoGroupArray\n                var obstructionsAbove = findOverlaps(target, target.x(), startingLocationAbove, layerChildren).map(x => x.attrs.cargoId);\n                var cargoGroupArrayAbove = cargoGroupArray.filter((cargo) => !obstructionsAbove.find(obstruction => obstruction === cargo[0].attrs.cargoId));\n\n                var pushDistanceAbove = Math.abs(target.y() - (aboveCargoY + aboveCargoRect.height + 1))\n            }\n\n            if (dedupeCargo.below.length > 0) {\n                var belowCargo = dedupeCargo.below[0][0]\n                var belowCargoY = dedupeCargo.below[0][1]\n                var belowCargoRect = belowCargo.findOne('Rect').getClientRect();\n                var startingLocationBelow = belowCargoY - targetRect.height - 1;\n                var remWallObstructionBelow = processWallCollisions(target, target.x(), startingLocationBelow, layerChildren)[1];\n                var layerChildrenRemWallBelow = layerChildren.filter(x => !(x.attrs.truckId === remWallObstructionBelow));\n\n                var obstructionsBelow = findOverlaps(target, target.x(), startingLocationBelow, layerChildren).map(x => x.attrs.cargoId);\n                var cargoGroupArrayBelow = cargoGroupArray.filter((cargo) => !obstructionsBelow.find(obstruction => obstruction === cargo[0].attrs.cargoId));\n\n                var pushDistanceBelow = Math.abs((target.y() + targetRect.height + 1) - belowCargoY)\n            }\n\n            if (dedupeCargo.left.length > 0) {\n                var leftCargo = dedupeCargo.left[0][0]\n                var leftCargoX = dedupeCargo.left[0][1]\n                var leftCargoRect = leftCargo.findOne('Rect').getClientRect();\n                var startingLocationLeft = leftCargoX + leftCargoRect.width + 1;\n                var remWallObstructionLeft = processWallCollisions(target, startingLocationLeft, target.y(), layerChildren)[1];\n                var layerChildrenRemWallLeft = layerChildren.filter(x => !(x.attrs.truckId === remWallObstructionLeft));\n\n                var obstructionsLeft = findOverlaps(target, startingLocationLeft, target.y(), layerChildren).map(x => x.attrs.cargoId);\n                var cargoGroupArrayLeft = cargoGroupArray.filter((cargo) => !obstructionsLeft.find(obstruction => obstruction === cargo[0].attrs.cargoId))\n\n                var pushDistanceLeft = Math.abs(target.x() - (leftCargoX + leftCargoRect.width + 1))\n            }\n\n            if (dedupeCargo.right.length > 0) {\n                var rightCargo = dedupeCargo.right[0][0]\n                var rightCargoX = dedupeCargo.right[0][1]\n                var rightCargoRect = rightCargo.findOne('Rect').getClientRect();\n                var startingLocationRight = rightCargoX - targetRect.width - 1;\n                // find any walls which may be impacted when placing the target at its' startingLocation and remove it\n                var remWallObstructionRight = processWallCollisions(target, startingLocationRight, target.y(), layerChildren)[1];\n                var layerChildrenRemWallRight = layerChildren.filter(x => !(x.attrs.truckId === remWallObstructionRight));\n\n                var obstructionsRight = findOverlaps(target, startingLocationRight, target.y(), layerChildren).map(x => x.attrs.cargoId);\n                var cargoGroupArrayRight = cargoGroupArray.filter((cargo) => !obstructionsRight.find(obstruction => obstruction === cargo[0].attrs.cargoId))\n\n                var pushDistanceRight = Math.abs((target.x() + targetRect.width + 1) - rightCargoX);\n            }\n\n            // dprt(\"pixelPush: pushDistances before: [pushDistanceAbove, pushDistanceBelow, pushDistanceRight, pushDistanceLeft]: \",\n            //     [pushDistanceAbove, pushDistanceBelow, pushDistanceRight, pushDistanceLeft]); //tmpdbg\n\n            function orthPixelPush(dir, startingLocation, pushDistance, orthCargoGroupArray, layerChildrenRemWallObstruction) {\n                //dprt(\"pixelPush: orthPixelPush: dir\", dir, \" has pushDistance: \", pushDistance, \" and has startingLocation: \", startingLocation); //tmpdbg\n\n                //startingLocation must be applied after pushDistance is computed, because pushDistance depends on the target's\n                //coordinates to compute overlap before pixel pushing begins\n                // target.y(startingLocation); // above or below\n                // target.x(startingLocation); // right or left\n                switch (true) {\n                    case ((dir === 'above') || (dir === 'below')):\n                        target.y(startingLocation); // above or below\n                        break;\n                    case ((dir === 'right') || (dir === 'left')):\n                        target.x(startingLocation); // right or left\n                        break;\n                    default:\n                        // no other keys exist\n                        break;\n                }\n\n                for (let i = 0; i < pushDistance; i++) {\n                    var targetPrePushX = target.x()\n                    var targetPrePushY = target.y()\n                    //dprt(\"pixelPush: orthPixelPush: [targetPrePushX, targetPrePushY]\", [targetPrePushX, targetPrePushY]) //tmpdbg\n                    \n                    switch (dir) {\n                        case 'above':\n                            target.y(target.y() - 1);\n                            pushDistanceAbove = pushDistanceAbove - 1;\n                            break;\n                        case 'below':\n                            target.y(target.y() + 1);\n                            pushDistanceBelow = pushDistanceBelow - 1;\n                            break;\n                        case 'right':\n                            target.x(target.x() + 1);\n                            pushDistanceRight = pushDistanceRight - 1;\n                            break;\n                        case 'left':\n                            target.x(target.x() - 1);\n                            pushDistanceLeft = pushDistanceLeft - 1;\n                            break;\n                        default:\n                            // no other keys exist\n                            break;\n                    }\n\n                    // above: below: right: left:, cargoGroupArray{Above, Below, Left, Right}:\n                    var orthPiRes = processImpact(target, target.x(), target.y(), 'isNotWall', orthCargoGroupArray, \"\", layerChildrenRemWallObstruction)\n                    //dprt(\"pixelPush: orthPixelPush: [dir, orthPiRes]\", [dir, JSON.stringify(orthPiRes.map(x => [x[0].attrs.cargoId, x[1], x[2], x[3]]))]); //tmpdbg\n\n                    //await sleep(100); // use requires async keyword in pixelPushFromBorder and outer function pixelPush \n                    // You must update cargogrouparray with processImpact results or else collided cargo will keep\n                    // using the stale konva object coordinates the cargoGroupArray.map call initializes the nested \n                    // array values to at the top of this function. These array values are used in the haveIntersection \n                    // call in processImpact when computing resolvedArray from unresolved array to allow lazy update\n                    // of coordinates after processImpact is complete, instead of updating the konva objects directly.\n                    // above: below: right: left:, cargoGroupArray{Above, Below, Left, Right}:\n                    updateCargoGroupArray(orthPiRes, orthCargoGroupArray);\n                    orthPiRes.forEach(function (kgroup) {\n                        var collidedItem = kgroup[0];\n                        collidedItem.x(kgroup[1]);\n                        collidedItem.y(kgroup[2]);\n                    })\n\n                    var targetPostPushX = target.x()\n                    var targetPostPushY = target.y()\n                    //dprt(\"pixelPush: orthPixelPush: [targetPostPushX, targetPostPushY]\", [targetPostPushX, targetPostPushY]) //tmpdbg\n                    if (targetPrePushX == targetPostPushX && targetPrePushY == targetPostPushY) {\n                        switch (dir) {\n                            case 'above':\n                                if (!(pushDistanceBelow === undefined)) { pushDistanceBelow = pushDistanceBelow + 1; }\n                                //dprt(\"pixelPush: orthPixelPush: opposite pushDistanceBelow increased: \", pushDistanceBelow) //tmpdbg\n                                break;\n                            case 'below':\n                                if (!(pushDistanceAbove === undefined)) { pushDistanceAbove = pushDistanceAbove + 1; }\n                                //dprt(\"pixelPush: orthPixelPush: opposite pushDistanceAbove increased: \", pushDistanceAbove) //tmpdbg\n                                break;\n                            case 'right':\n                                if (!(pushDistanceLeft === undefined)) { pushDistanceLeft = pushDistanceLeft + 1; }\n                                //dprt(\"pixelPush: orthPixelPush: opposite pushDistanceLeft increased: \", pushDistanceLeft) //tmpdbg\n                                break;\n                            case 'left':\n                                if (!(pushDistanceRight === undefined)) { pushDistanceRight = pushDistanceRight + 1; }\n                                //dprt(\"pixelPush: orthPixelPush: opposite pushDistanceRight increased: \", pushDistanceRight) //tmpdbg\n                                break;\n                            default:\n                                // no other keys exist\n                                break;\n                        }\n                    } else {\n                        // update the starting location to follow the moved cargo in case it must be repushed in the round robin below\n                        switch (dir) {\n                            case 'above':\n                                if (!(startingLocationAbove === undefined)) { startingLocationAbove = startingLocationAbove - 1; }\n                                //dprt(\"pixelPush: orthPixelPush: in same dir startingLocationAbove increased: \", startingLocationAbove) //tmpdbg\n                                break;\n                            case 'below':\n                                if (!(startingLocationBelow === undefined)) { startingLocationBelow = startingLocationBelow + 1; }\n                                //dprt(\"pixelPush: orthPixelPush: in same dir startingLocationBelow increased: \", startingLocationBelow) //tmpdbg\n                                break;\n                            case 'right':\n                                if (!(startingLocationRight === undefined)) { startingLocationRight = startingLocationRight + 1; }\n                                //dprt(\"pixelPush: orthPixelPush: in same dir startingLocationRight increased: \", startingLocationRight) //tmpdbg\n                                break;\n                            case 'left':\n                                if (!(startingLocationLeft === undefined)) { startingLocationLeft = startingLocationLeft - 1; }\n                                //dprt(\"pixelPush: orthPixelPush: in same dir startingLocationLeft increased: \", startingLocationLeft) //tmpdbg\n                                break;\n                            default:\n                                // no other keys exist\n                                break;\n                        }\n                    }\n                }\n            }\n\n            var bedRockCount = 0            \n            while (pushDistanceAbove > 0 || pushDistanceBelow > 0 || pushDistanceRight > 0 || pushDistanceLeft > 0) {\n                if((Math.trunc(pushDistanceAbove) == 0 || Math.trunc(pushDistanceBelow) == 0 || \n                    Math.trunc(pushDistanceRight) == 0 || Math.trunc(pushDistanceLeft) == 0)) {\n                    bedRockCount = bedRockCount + 1;\n                    // dprt(\"one pushDistance has hit zero: [pushDistanceAbove, pushDistanceBelow, pushDistanceRight, pushDistanceLeft, bedRockCount]\", \n                    //       [pushDistanceAbove, pushDistanceBelow, pushDistanceRight, pushDistanceLeft, bedRockCount]); //tmpdbg\n                    if(bedRockCount == 20){\n                        //console.log(\"pixelPush: ERROR: bedRockCount == 20; abandoning collision resolution\"); //tmpdbg\n                        break;    \n                    }\n                }\n                for (const dir in dedupeCargo) {\n                    if (dedupeCargo[dir].length > 0) {\n                        switch (dir) {\n                            case 'above':\n                                orthPixelPush('above', startingLocationAbove, pushDistanceAbove, cargoGroupArrayAbove, layerChildrenRemWallAbove);\n                                break;\n                            case 'below':\n                                orthPixelPush('below', startingLocationBelow, pushDistanceBelow, cargoGroupArrayBelow, layerChildrenRemWallBelow);\n                                break;\n                            case 'right':\n                                orthPixelPush('right', startingLocationRight, pushDistanceRight, cargoGroupArrayRight, layerChildrenRemWallRight)\n                                break;\n                            case 'left':\n                                orthPixelPush('left', startingLocationLeft, pushDistanceLeft, cargoGroupArrayLeft, layerChildrenRemWallLeft);\n                                break;\n                            default:\n                                // no other keys exist    \n                                break;\n                        }\n                    }\n                }\n            }            \n            // dprt(\"pixelPush: pushDistances after: [pushDistanceAbove, pushDistanceBelow, pushDistanceRight, pushDistanceLeft]: \",\n            //     [pushDistanceAbove, pushDistanceBelow, pushDistanceRight, pushDistanceLeft]); //tmpdbg\n            var finalCheckCargo = findOverlaps(target, target.x(), target.y(), layerChildren)\n            // [Group1, Group2, ...]\n            var finalCheckWalls = processWallCollisions(target, target.x(), target.y(), layerChildren);\n            // [[Group, 797, 68, 'isNotWall'], \"rightWall\"]\n\n            if (finalCheckCargo.length > 0 || !(finalCheckWalls[1] === 'isNotWall')) {\n                target.x(saveStartDragCoords.x);\n                target.y(saveStartDragCoords.y);\n            }\n            //dprt(\"pixelPush finalCheck Result: [finalCheckCargo, finalCheckWalls]\", [finalCheckCargo, finalCheckWalls]) //tmpdbg\n        }\n    }\n}\n\n\n/* eslint-enable */\n\n\n\n","import { render } from \"./EzLoading.vue?vue&type=template&id=6e50404e&scoped=true\"\nimport script from \"./EzLoading.vue?vue&type=script&lang=js\"\nexport * from \"./EzLoading.vue?vue&type=script&lang=js\"\n\nimport \"./EzLoading.vue?vue&type=style&index=0&id=6e50404e&scoped=true&lang=css\"\n\nimport exportComponent from \"../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-6e50404e\"]])\n\nexport default __exports__","import { render } from \"./App.vue?vue&type=template&id=5685f6f0\"\nimport script from \"./App.vue?vue&type=script&lang=js\"\nexport * from \"./App.vue?vue&type=script&lang=js\"\n\nimport \"./App.vue?vue&type=style&index=0&id=5685f6f0&lang=css\"\n\nimport exportComponent from \"../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import { createApp } from 'vue';\r\nimport App from './App.vue';\r\nimport VueKonva from 'vue-konva';\r\n\r\n\r\n// Vuetify\r\nimport 'vuetify/styles'\r\nimport { createVuetify } from 'vuetify'\r\nimport * as components from 'vuetify/components'\r\nimport * as directives from 'vuetify/directives'\r\n\r\nconst vuetify = createVuetify({\r\n  components,\r\n  directives,\r\n})\r\n\r\n\r\n\r\nconst app = createApp(App);\r\napp.use(VueKonva);\r\napp.use(vuetify);\r\napp.mount('#app');\r\n\r\n\r\n//createApp(App).use(vuetify).mount('#app')\r\n\r\n\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t143: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = function(parentChunkLoadingFunction, data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkezloading\"] = self[\"webpackChunkezloading\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [998], function() { return __webpack_require__(5809); })\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["_createBlock","_component_EzLoading","class","_createVNode","_component_v_layout","_component_v_app_bar","color","_component_v_app_bar_nav_icon","onClick","_cache","_withModifiers","$event","$data","drawer","_createElementVNode","_hoisted_1","_component_truck_dialog","customClasses","variantStyle","customColor","mobileOrDesktop","displayWidth","customStyle","backgroundColor","onLoadSpaceSet","$options","loadSpaceSet","_component_add_dialog","onCargoAdded","addCargo","_component_v_app_bar_title","_component_v_navigation_drawer","location","temporary","_hoisted_2","_component_v_sheet","blockStyle","_createElementBlock","_Fragment","_renderList","generateNavDrawerList","item","_component_v_container","key","title","_component_v_row","_component_v_col","cols","style","userSelect","_component_v_btn","variant","density","icon","deleteCargoCategory","onTap","deleteCargoCategoryItem","value","length","_component_v_main","id","_component_v_stage","ref","config","stageConfig","_component_v_layer","onMousemove","handleMouseMove","onPointerdown","handlePointerDown","onDragstart","handleDragStart","onDragmove","handleDragMove","onDragend","handleDragEnd","_component_v_rect","truckId","truck","originx","originy","units","dimy","scaleFactor","dimx","cargo","index","_component_pallet_konva_group","lowestYBound","onDeleteCargo","deleteCargo","onRotateCargo","rotateCargo","_component_v_dialog","dialog","width","$setup","activator","_withCtx","props","$props","_mergeProps","block","_component_v_card","_component_v_card_title","_component_v_form","onSubmit","_component_v_select","label","selectedUnits","newUnitSelected","items","unitChoice","_component_v_text_field","onChange","Number","parseFloat","toFixed","toString","unit","suffix","rules","dimRules","metricPallet","newMetricPalletSelected","metricPalletSizes","imperialPallet","newImperialPalletSelected","imperialPalletSizes","_component_v_card_actions","_component_v_spacer","String","Boolean","Object","setup","name","useDisplay","computed","data","isNaN","desc","tuple","methods","this","$emit","$refs","addCargoForm","resetValidation","__exports__","metricLoadingSpace","metricLoadingSpaceSizes","imperialLoadingSpace","imperialLoadingSpaceSizes","setTruckSizeForm","_component_v_group","cargoId","Math","floor","_component_v_text","max","_ctx","onMouseover","mouseoverPointer","onMouseout","mouseoutPointer","closeIcon","rotateIcon","_component_v_line","mounted","Image","src","onload","cargoGroupRef","getNode","x","y","document","body","cursor","mergeArrays","resolvedArray","processImpactResult","saveIndex","foundIndex","findIndex","attrs","splice","haveIntersection","collidedItem","collidedItemBareRect","targetRect","targetXPos","targetYPos","collidedItemX","collidedItemY","intersectionResult","height","targetCenterX","targetCenterY","collidedItemCenterX","collidedItemCenterY","centerDeltaX","centerDeltaY","transformx","abs","transformy","intersectionObj","transform","processWallCollisions","target","layerChildren","findOne","getClientRect","leftWall","find","el","backWall","rightWall","wall","wallLocation","backWallCoords","left","right","top","bottom","leftWallCoords","rightWallCoords","targetRectCoords","overlapArea","rect1","rect2","x_overlap","min","y_overlap","overlapAreaArray","intersectLeftWallCargo","intersectRightWallCargo","intersectBackWallCargo","processImpact","wallStatus","unresolvedArray","stackName","random","processWallCollisionsResult","wallCollision","inheritCollision","map","bareRect","preCollisionIntersection","intersection","bind","filter","undefined","accumArray","forEach","newTarget","newTargetXPos","newTargetYPos","newUnresolvedArray","newResolvedArray","concat","blowbackTargetArray","checkIndex","blowbackUnresolvedArray","slice","blowbackResult","blowbackCargoTarget","temp","findOverlaps","layerChildrenNoTarget","cargoArray","targetIntersectionArray","dedupeStackedCargo","targetId","cargoGroupArray","unresolvedArrayIntersection","belowArray","rightArray","leftArray","aboveArray","dedupeStackedCargoBelow","sort","a","b","dedupeStackedCargoRight","dedupeStackedCargoLeft","dedupeStackedCargoAbove","dedupedResult","above","below","updateCargoGroupArray","piRes","resolved","resolvedId","resolvedX","resolvedY","foundCargoIndex","pixelPush","saveStartDragCoords","bottomOfBackWall","rightOfLeftWall","leftOfRightWall","resWall","pixelPushFromBorder","startWallPushX","startWallPushY","postWallCollisionX","postWallCollisionY","layerChildrenRemoveWall","i","collidedWall","kgroup","resWallPostColl","collidedWallPostColl","dedupeCargo","totalDedupedElements","aboveCargo","aboveCargoY","aboveCargoRect","startingLocationAbove","remWallObstructionAbove","layerChildrenRemWallAbove","obstructionsAbove","cargoGroupArrayAbove","obstruction","pushDistanceAbove","belowCargo","belowCargoY","startingLocationBelow","remWallObstructionBelow","layerChildrenRemWallBelow","obstructionsBelow","cargoGroupArrayBelow","pushDistanceBelow","leftCargo","leftCargoX","leftCargoRect","startingLocationLeft","remWallObstructionLeft","layerChildrenRemWallLeft","obstructionsLeft","cargoGroupArrayLeft","pushDistanceLeft","rightCargo","rightCargoX","startingLocationRight","remWallObstructionRight","layerChildrenRemWallRight","obstructionsRight","cargoGroupArrayRight","pushDistanceRight","orthPixelPush","dir","startingLocation","pushDistance","orthCargoGroupArray","layerChildrenRemWallObstruction","targetPrePushX","targetPrePushY","orthPiRes","targetPostPushX","targetPostPushY","bedRockCount","trunc","finalCheckCargo","finalCheckWalls","window","innerWidth","innerHeight","components","AddDialog","TruckDialog","PalletKonvaGroup","stage","getStage","container","border","addEventListener","resizeStage","truckLocationX","unmounted","removeEventListener","group","scaleX","scaleY","backingRectConfig","fill","prObj","obj","JSON","stringify","prt","variableName","debugVar","console","log","TESTING_BUTTON1","layer","getLayer","children","TESTING_BUTTON2","TESTING_BUTTON3","TESTING_findOverlaps","collision","TESTING_dedupeStackedCargo_dummy","TESTING_pixelPush_dummy","TESTING_Setup1","TESTING_Setup2","testCargo1","testCargo2","TESTING_PrintCargo","table","TESTING_ForceHighlight","topBorder","bottomBorder","rightBorder","leftBorder","stroke","shadowEnabled","processImpactStart","event","cargoItem","cargoKObj","isCargoOutside","collidedCargoArray","collidedCargo","collidedCargoRect","guideLinesoldversion","targetFirstXPos","absolutePosition","targetThirdXPos","targetFirstYPos","targetThirdYPos","drawGuide","orientation","anchorCoordinate","line","Konva","Line","points","strokeWidth","dash","add","generateGuidelineObject","kObj","kObjRect","leftGuide","startInterval","endInterval","anchor","rightGuide","aboveGuide","belowGuide","guideLinesArray","g","isFirstXPosInGutter","isThirdXPosInGutter","batchDraw","leftGuideLine","destroy","rightGuideLine","isFirstYPosInGutter","isThirdYPosInGutter","aboveGuideLine","belowGuideLine","guideLines","position","guideWalls","wallOverlap","wallsArray","wallObj","TESTING_guideWalls","cargoGroupArrayIntersect","opacity","getParent","moveToTop","l","cargoNoWallsArray","moveToBottom","uniqueId","push","drawerItem","cargoEl","lastCargoCategoryItem","deleteCargoCategoryItemIndex","tempdimx","parentOfContainerWidth","getElementById","parentNode","offsetWidth","truckWidth","stageWidth","round","allChildren","cargoGroupElements","groupedCargo","groupBy","groupedCargoArrayStr","entries","element","split","groupedCargoArray","parseInt","orderedGroupedCargoArray","orderBy","navDrawerListArray","watch","EzLoading","render","vuetify","createVuetify","directives","app","createApp","App","use","VueKonva","mount","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","loaded","__webpack_modules__","call","m","deferred","O","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","keys","every","r","n","getter","__esModule","d","definition","o","defineProperty","enumerable","get","globalThis","Function","e","prop","prototype","hasOwnProperty","Symbol","toStringTag","nmd","paths","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","some","chunkLoadingGlobal","self","__webpack_exports__"],"sourceRoot":""}